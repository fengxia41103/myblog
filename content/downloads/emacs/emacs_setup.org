+TITLE: Feng's Emacs configuration
#+AUTHOR: Feng Xia
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+LATEX_COMPILER: xelatex
#+STARTUP: indent

I have seen others using org-mode to mangae emacs config, and they
came out very nicely. Finally, after 4 years of using emacs, I ran
into [[https://github.com/pascalfleury/emacs-config][Pascal Fleury]] portal emacs config, and it makes sense to me!!
After trying it out for a couple weeks now, I really like it! So now
after the configs are stable to my taste, and is also growing slowly
when I add new packages and custom stuff, I find the original sections
a bit, confusing. So I'm to take his copy and rearrange it so it fits
my way of thinking. I will not change the fundamental things such as
=tangle=, but will clarify what the packages and configs are about.

* The idea

This idea is actually a bit chicken-egg: in order to tangle, you must
first fire up emacs, then convert this org to =.el=, then load it back
into emacs to take effect.

The key here are relying on two things:

1. There are two version of the =emacs_setup.el= file, one is a dummy
   short version that gets loaded for the very first time. This is the
   same stuff you can recreate using the [[manual tangle]]: =C-c C-v t=.
2. In the default =.emacs, write one line: to load this =.el= file. Then,
   it short version will tangle this org file, and write over itself
   (on disk), thus literally replaced itself w/ more contents. At this
   point, it will tangle all the code blocks in this file, and at the
   end of it, it will call to [[#recompile-packages][recompile packages]], thus kicking off the
   entire download, compiling, installation and configuration.

* Deps

There are some host packages/tools you need to install. These are not
hard dependencies, but really, it works better that way if they are there.

I have been thinking how to handle them. The original author uses
tangle to create a bash file. So the idea is to run this =.sh=
first. But then, I think there are two problems:

1. host package manager is different, eg. =apt= for Ubuntu, and =yum= for Cent.
2. package name changes sometimes, and not mention, the packages are
   completely different among distributions.

   So all in all, I think it's much better to simply list what I want
   to have, and then let some offline research/google to handle how to
   install them. Another idea is to build a Docker image w/ all thest
   inside. Hmm... I may try that someday.

** what I want to use

I'll simply keep a list:

1. [[https://github.com/ggreer/the_silver_searcher][silver searcher, aka. ag]]
2. [[https://github.com/nvm-sh/nvm][nvm]]: needed for Node
3. [[https://prettier.io/docs/en/install.html][prettier]]: require Node first
4. sqlite3: needed by org-roam
5. [[https://github.com/hakimel/reveal.js/][reveal.js]]: needed to enable org-export to reveal slides
6. [[https://plantuml.com/download][plantuml.jar]]
7. [[https://packages.ubuntu.com/search?keywords=mu4e][mu4e]] & [[https://packages.ubuntu.com/search?keywords=isync][isync]] (this give you =mbsync=)
8. [[https://github.com/mguessan/davmail][davmail]]

* Clean start

*ASSUMPTION*:

1. you have installed emacs. Using v26.3 as of writing.
2. determine where to put this org file. Throughout this doc, we are
   assuming =~/Emacs/= as the folder.

Once you are here, starting from a clean sheet is pretty easy:

1. delete all your old =.emacs=, =.emacs.d=, or back them up somewhere.
2. tangle this org file into a ~.el~ file. To make things easier, I'm
   going to include the =.el= in the repo. So just copy it.
3. create a ~.emacs~ file, and write one line =(load-file
   "~/Emacs/emacs_setup.el")=, essentially tells emacs where to find
   the initial config file.
4. make sure Emacs re-interprets its init (you could restart it).

That's it. Just sit back and watch emacs download and compile things,
and after it's done, you will be given the power of this beautiful
editor, all configured and ready to go! Now to think of it, isn't this
what LOC is trying to achieve!?

** .emacs

I have my config in directory =~/Emacs= which is where I clone this
repository. The config setup is maintained purely in the
=~/Emacs/emacs_setup.org= file.

In your =~/.emacs= file, all you need to add is

#+NAME: emacs_bootstrap
#+BEGIN_SRC emacs-lisp :tangle ./dot_emacs.el
  ;; Loads Feng's emacs setup with bootstrap
  (load-file "~/Emacs/emacs_setup.el")
#+END_SRC

** bootstrap.el

Put this in the =~/Emacs/emacs_setup.el=, and viola, it will regnerate itself!

#+BEGIN_SRC emacs-lisp :tangle /tmp/emacs_setup.el

;; This is the initial state of the file to be loaded.
;; It will replace itself with the actual configuration at first run.

(require 'org) ; We can't tangle without org!

(setq config_base (expand-file-name "emacs_setup"
				    (file-name-directory
				     (or load-file-name buffer-file-name))))
(find-file (concat config_base ".org"))        ; Open the configuration
(org-babel-tangle)                             ; tangle it
(load-file (concat config_base ".el"))         ; load it
(byte-compile-file (concat config_base ".el")) ; finally byte-compile it
#+END_SRC

* Reset

Reset takes two steps, but you can do either or both, depending on
what you are trying to reset.

** reset config

If you have made a change to this org and what's to test drive it, you
need to either [[manual tangle]] or just save this file to trigger [[auto
tangle]]. Sometimes, I found I have to go the [[manual tangle]] route
because the hook is not fired. This is understandable that when I'm
changing this file, it may render a broken config, thus the hook and
all others can be in a comprised state when you start emacs.

** recompile all packages
:PROPERTIES:
:CUSTOM_ID: recompile-packages
:END:

This is the *RESET* button. This will force-recompile everything in
=~/.emacs.d/elpa/...= Just run =M-:= and then enter this:

#+BEGIN_SRC emacs-lisp :tangle no
  (byte-recompile-directory package-user-dir nil 'force)
#+END_SRC

or simply =C-x C-e= at the end of that line.

*Note* that by setting =:tangle no=, this piece of code will be included
into the =.el= file. So it stays inside this org. Nice.

* Initialize emacs

** info header

Just to add a little information in the tangled file so you don't
*manually* mess with the generated =.el= file.

#+BEGIN_SRC emacs-lisp
;; ===== this file was auto-tangled, only edit the emacs_setup.org =====
#+END_SRC

** melpa

Make sure we have the package system initialized before we load anything.

#+BEGIN_SRC emacs-lisp
(require 'package)
(when (< emacs-major-version 27)
  (package-initialize))
#+END_SRC

Adding my choice of packages repositories.

#+NAME melpa-setup
#+BEGIN_SRC emacs-lisp
(setq package-archives '(("org" . "https://orgmode.org/elpa/")
                         ("stable-melpa" . "https://stable.melpa.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("gnu" . "https://elpa.gnu.org/packages/")
                        ))
#+END_SRC

** use-package

I use =use-package= for most configuration, and that needs to be at the
top of the file.  =use-package= verifies the presence of the requested
package, otherwise installs it, and presents convenient sections for
configs of variables, key bindings etc. that happen only if the
package is actually loaded.

First, make sure it gets installed if it is not there yet.

#+BEGIN_SRC emacs-lisp
  ;; make sure use-package is installed
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'use-package))
#+END_SRC

** tangle this config
*** manual tangle

I have setup auto tangle in the header as =:tangle yes=. So upon save,
this org file will be tangled into an ~.el~ file, and that is the file
emacs should load.

Alternatively, use the =C-c C-v t= [org-babel-tangle] to do this
manually.

*** auto tangle

I set this up to tangle the init org-mode file into the actual Emacs
init file as soon as I save it.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled,
  and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name "~/Emacs/emacs_setup.org"))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file "~/Emacs/emacs_setup.el"))))

  ;; auto-tangle hook
  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

#+RESULTS:

** surpress "add-handle-definition..." error

#+BEGIN_SRC emacs-lisp
(custom-set-variables '(ad-redefinition-action (quote accept)))
#+END_SRC

* Base packages

There are some packages you'd better load prior to everything else, so
that when other packages are being configured, they are already
available. For example, the .

** all-the-icons

Want fancy [[https://github.com/domtronn/all-the-icons.el#installation][icons]]:

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p))
#+END_SRC

You would have to run =M-x all-the-icons-install-fonts= manually at
least once to install fonts to your system.

** rainbow-mode

Colorize color names and codes in the correct color.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :delight)
#+END_SRC

** Hydra
:PROPERTIES:
:CUSTOM_ID: hydra
:END:

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC

** whichkey

Give me a hint when I'm entering a keybinding:
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure
    :config
    (which-key-setup-side-window-right))
  (which-key-mode)
#+END_SRC

* Global stuff

Some global settings such as line number. Well, just about everything
of emacs are global in a sense, say, a package, will affect the look
and behavior when loaded. Even though the mode could be refined to be
loaded only for some file pattern, but hey, the fun is about loading
these funky modes, and with them, a million funky keybinding combos to
remember.

So here, just some obvious value settings. If I find some to be more
topic specific, I will move them into that topic's section instead.

** by packages

These are achieved by using someone's package.

*** UTF-8

Make Emacs request UTF-8 first when pasting stuff

#+BEGIN_SRC emacs-lisp
(use-package unicode-escape
  :ensure t
  :init
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
(set-language-environment "UTF-8")
#+END_SRC

*** shell env

#+BEGIN_SRC emacs-lisp
(setq exec-path-from-shell-debug t)
(setenv "SHELL" "/usr/bin/zsh")
(use-package exec-path-from-shell
  :ensure t
  :if (memq window-system '(mac ns x))
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

** UTF-8 env

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)

  (setenv "LANG" "en_US.UTF-8")
  (setenv "LC_ALL" "en_US.UTF-8")
  (setenv "LC_CTYPE" "en_US.UTF-8")
  (set-language-environment "UTF-8")
#+END_SRC

** browser (default: chrome)

I like Chrome. Period.

#+BEGIN_SRC emacs-lisp
(setq browse-url-generic-program (executable-find "google-chrome")
  browse-url-browser-function 'browse-url-generic)
#+END_SRC

** emacs server (default: off)

Start the background server, so we can use emacsclient.

#+BEGIN_SRC emacs-lisp :tangle no
(server-start)
#+END_SRC

** newline (only Unix wanted)

This should automatically convert any files with dos or Mac line
endings into Unix style ones. Code found [[https://www.emacswiki.org/emacs/EndOfLineTips][here]].

#+BEGIN_SRC emacs-lisp
  (defun no-junk-please-we-are-unixish ()
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hook 'no-junk-please-we-are-unixish)
#+END_SRC

** auto revert

Use =auto-revert=, which reloads a file if it's updated on disk and not
modified in the buffer.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** yes-or-no

Change all prompts to y or n:

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** hide menu bar & toolbar
Using i3 is forcing me to use keyboard.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)
  (blink-cursor-mode -1)
#+END_SRC

** alternate key mappings

Letting one enter chars that are otherwise difficult in e.g. the
minibuffer.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-m") 'newline-and-indent)
  (global-set-key (kbd "C-j") 'newline)
  (global-set-key [delete] 'delete-char)
  (global-set-key [kp-delete] 'delete-char)
#+END_SRC

** macros (default: off)

#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key [f3] 'start-kbd-macro)
  (global-set-key [f4] 'end-kbd-macro)
  (global-set-key [f5] 'call-last-kbd-macro)
#+END_SRC

** linum

For now, I'm doing it globally.

#+BEGIN_SRC emacs-lisp :tangle no
(global-display-line-numbers-mode t)
#+END_SRC


Yes I like having line numbers, but turnning it on globally makes some
buffers look strange. So let's limit it to the ones that I think
brings value. *Note* that the ones I skip are:

1. mu4e-compose-mode: when writing email, it's better not to count for line num.
2. markdown: for the same reason. I'm writing.

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook 'display-line-numbers-mode)
  ;; (add-hook 'org-mode-hook 'display-line-numbers-mode)
  (add-hook 'python-mode-hook 'display-line-numbers-mode)
  (add-hook 'web-mode-hook 'display-line-numbers-mode)
  (add-hook 'js2-mode-hook 'display-line-numbers-mode)
  (add-hook 'yaml-mode-hook 'display-line-numbers-mode)
  (add-hook 'json-mode-hook 'display-line-numbers-mode)
  (add-hook 'java-mode-hook 'display-line-numbers-mode)
  (add-hook 'groovy-mode-hook 'display-line-numbers-mode)
#+END_SRC

Format the line no and add a solid line as separation:

#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-width nil)
(setq linum-format "%4d ")
#+END_SRC

** disable electric-indent

This is very annoying that it keeps indenting.

#+BEGIN_SRC emacs-lisp
(electric-indent-mode -1)
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC

** set clipboard to utf-8

This makes copy & paste from terminal to emacs buffer
work. Otherwise, some utf-8 symbols will be scrambled.

#+BEGIN_SRC emacs-lisp
(set-clipboard-coding-system 'utf-8)
#+END_SRC

* Font, theme

The whole point of using emacs is that I like the user experience, and
a big part of it is the color and look. There are too many ways to
tweak it. So I'll try not to run wild on this one. Most are inherited
from the original post, and I added some while playing with this
setting. Enjoy ~~

** by packages

*** sublime themes (default: spolsky)

Loading a theme I like.

#+BEGIN_SRC emacs-lisp
  (use-package sublime-themes
    :ensure t
    :config)
  (load-theme 'spolsky t)
#+END_SRC

*** mode lines
**** doom-modeline

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1))
#+END_SRC

**** remove some modelines

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :delight)
#+END_SRC

**** nyan-mode

#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :ensure t
  :bind ("C-M-x n" . 'nyan-mode))
#+END_SRC

*** delight

Package to remove some info from the mode-line for minor-modes.

#+BEGIN_SRC emacs-lisp
  (use-package delight
    :ensure t)

 (delight '((abbrev-mode " Abv" abbrev)
            (smart-tab-mode " \\t" smart-tab)
            (eldoc-mode nil "eldoc")
            (rainbow-mode)
            (overwrite-mode " Ov" t)
            (emacs-lisp-mode "Elisp" :major)))
#+END_SRC

*** multiple-cursors

Configure the shortcuts for multiple cursors.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . 'mc/edit-lines)
         ("C->" . 'mc/mark-next-like-this)
         ("C-<" . 'mc/mark-previous-like-this)
         ("C-c C->" . 'mc/mark-all-like-this)))
#+END_SRC

*** dimmer

This will dim the buffer that is not the current. Sort of a visual
cue. However, I found that it can be ugly depending the theme.

#+BEGIN_SRC emacs-lisp
  (use-package dimmer
    :ensure
    :config
    (dimmer-configure-which-key)
    (dimmer-configure-helm))
  (dimmer-mode t)
#+END_SRC

*** highlight indent

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
  :ensure
  :config
  (setq highlight-indent-guides-method 'character))
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
#+END_SRC

** fontlock

This gets the font coloring switched on for all buffers.

I have encountered a strange case when a mal-formatted Java file
caused Emacs to crash. After many research, the remedy is to use
[[https://github.com/jhipster/prettier-java][prettier-java]] to reformat this file first, then emacs is happy.

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

** faces
**** list all the fonts

To list all the fonts available to your emacs, put this snippet to scratch, and
run =C-x C-e=:

#+BEGIN_SRC emacs-list :tangle no
(dolist (font (x-list-fonts "*"))
  (insert (format "%s\n" font)))
#+END_SRC

**** highlight, region

This makes some of the faces a bit more contrasted.

#+BEGIN_SRC emacs-lisp
  ;; faces for general region highlighting zenburn is too low-key.
  (custom-set-faces
   '(highlight ((t (:background "forest green"))))
   '(region ((t (:background "forest green")))))
#+END_SRC

**** mono font

Set default mono font:

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
             '(font . "Ubuntu Mono-15"))
#+END_SRC

Set default font to monospace:
#+BEGIN_SRC emacs-lisp
;; set a default font
(when (member "Ubuntu Mono-15" (font-family-list))
  (set-face-attribute 'default nil :font "Ubuntu Mono-15"))
#+END_SRC

**** custome theme font

Remember to install =apt install fonts-firacode=.

#+BEGIN_SRC emacs-lisp
  (custom-theme-set-faces
   'user
   '(fixed-pitch ((t (:family "Fira Code" :height 140))))
  )
#+END_SRC

** be quiet
Remove bell and dings.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function
      '(lambda ()
         (message "The answer is 42...")))
(setq echo-keystrokes 0.1 use-dialog-box nil visible-bell t)
#+END_SRC

** In terminal mode

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (set-background-color "#ffffff")
  (set-foreground-color "#141312"))
#+END_SRC

** In X11 mode: mouse and window title

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "emacs @ %b - %f")
(when window-system
  (mouse-wheel-mode)  ;; enable wheelmouse support by default
  (set-selection-coding-system 'compound-text-with-extensions))
#+END_SRC

** dynamic cursor colors

The cursor is displayed in different colors, depending on overwrite or
insert mode.

#+BEGIN_SRC emacs-lisp
(setq hcz-set-cursor-color-color "")
(setq hcz-set-cursor-color-buffer "")

(defun hcz-set-cursor-color-according-to-mode ()
  "change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color
         (if buffer-read-only "orange"
           (if overwrite-mode "red"
             "green"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+END_SRC

* Coding

Big part of my life is taken by coding. So here it is, all the coding
related stuff.
** set authinfo as source

#+BEGIN_SRC emacs-lisp
(setq auth-sources '("~/.authinfo"))
#+END_SRC

** taskjuggler-mode (tj3-mode)
#+BEGIN_SRC emacs-lisp
  (use-package tj3-mode
    :ensure t
    :after org-plus-contrib
    :config
    (require 'ox-taskjuggler)
    (custom-set-variables
     '(org-taskjuggler-process-command "/usr/local/bin/tj3 --silent --no-color --output-dir %o %f")
     '(org-taskjuggler-project-tag "PRJ")))
#+END_SRC

** Version control
*** magit

Add the powerful Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer
    :config
    (add-hook 'after-save-hook 'magit-after-save-refresh-status t)
    :custom ((magit-diff-refine-hunk 'all)
             (magit-process-finish-apply-ansi-colors t))
    :bind ("C-x g" . 'magit-status))
  (use-package magit-todos
    :ensure t
    :defer)
  (use-package
    magit-gitflow

    :ensure
    :config (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
#+END_SRC

Add local workspace to manage multiple repositories:

#+BEGIN_SRC emacs-lisp
(setq magit-repository-directories
      `(("~/workspace/dhhs" . 2)))
(setq magit-repolist-columns
      '(("Name"    30 magit-repolist-column-ident ())
        ("Local On" 35 magit-repolist-column-branch ())
        ("B" 4 magit-repolist-column-branches ())
        ("L<U" 3 magit-repolist-column-unpulled-from-upstream
         ((:right-align t)
          (:help-echo "Upstream changes not in branch")))
        ("L>U" 3 magit-repolist-column-unpushed-to-upstream
         ((:right-align t)
          (:help-echo "Local changes not in upstream")))
       ))
#+END_SRC

Turn on ANSI-COLOR:

#+BEGIN_SRC emacs-lisp
(defun color-buffer (proc &rest args)
  (interactive)
  (with-current-buffer (process-buffer proc)
    (read-only-mode -1)
    (ansi-color-apply-on-region (point-min) (point-max))
    (read-only-mode 1)))

(advice-add 'magit-process-filter :after 'color-buffer)
#+END_SRC


Based on [[https://emacs.stackexchange.com/questions/19176/manage-several-git-repositories-from-magit][SO]]:
#+begin_src emacs-lisp
(magit-add-section-hook 'magit-status-sections-hook
                        'magit-insert-modules
                        'magit-insert-unpulled-from-pushremote)
#+end_src
*** monky
Add the Magit-copy for Mercurial 'monky'

#+BEGIN_SRC emacs-lisp
  (use-package monky
    :ensure t
    :defer
    :bind ("C-x m" . 'monky-status))
#+END_SRC

*** git informations in gutter
#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe+
  :ensure t
  :defer
  :if window-system
  :bind ("C-c g" . 'git-gutter+-mode))
#+END_SRC

*** speedup VCS
Regexp matching directory names that are not under VC's control. The
default regexp prevents fruitless and time-consuming attempts to
determine the VC status in directories in which filenames are
interpreted as hostnames.

#+BEGIN_SRC emacs-lisp
(defvar locate-dominating-stop-dir-regexp
  "\\`\\(?:[\\/][\\/][^\\/]+\\|/\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)\\'")
#+END_SRC

*** global caller

Have a single binding to call the most appropriate tool given the repository.

#+BEGIN_SRC emacs-lisp
  (defun paf/vcs-status ()
       (interactive)
       (condition-case nil
           (magit-status-setup-buffer)
         (error (monky-status))))

  (global-set-key (kbd "C-M-x v") 'paf/vcs-status)
#+END_SRC


#+RESULTS:
: paf/vcs-status
*** forge

#+BEGIN_SRC emacs-lisp
(use-package forge
  :after magit)
#+END_SRC

*** code review

This is really cool. It has fancier UI than the =github-review= tool.
Give it a shot!

#+BEGIN_SRC emacs-lisp :tangle no
(use-package code-review
  :ensure t)
(add-hook 'code-review-mode-hook #'emojify-mode)
(setq code-review-fill-column 80)
#+END_SRC

*** github review

I have been using [[https://github.com/charignon/github-review][this]] for a while daily, and it's wonderful!

#+BEGIN_SRC emacs-lisp
(use-package github-review
  :ensure t
  :config
  (setq github-review-reply-inline-comments t)
)
#+END_SRC

** Projectile

Start using projectile. It has the documentation [[https://docs.projectile.mx/en/latest/][here]].

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-completion-system 'helm)
    (projectile-mode +1))

  (use-package helm-projectile
    :ensure t
    :after projectile
    :requires projectile
    :delight projectile-mode
    :config
    (helm-projectile-on))
#+END_SRC


Search the entire project with =C-c p s s= for a regexp. This let's
you turn the matching results into an editable buffer using =C-c
C-e=. Other keys are listed [[https://github.com/syohex/emacs-helm-ag#keymap][here]].

#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :ensure t
    :config)
#+END_SRC


I havae used it by a =M-?= binding. It's just old habit:
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-?") 'helm-ag)
#+END_SRC

** debug w/ GDB
*** TODO Make it so that the source frame placement is forced only when using gdb.

#+BEGIN_SRC emacs-lisp
  (setq gdb-many-windows t)
  (setq gdb-use-separate-io-buffer t)

  (defun easy-gdb-top-of-stack-and-restore-windows ()
    (interactive)
    (switch-to-buffer (gdb-stack-buffer-name))
    (goto-char (point-min))
    (gdb-select-frame)
    (gdb-restore-windows)
    (other-window 2))

  (global-set-key (kbd "C-x C-a C-t") 'easy-gdb-top-of-stack-and-restore-windows)
#+END_SRC


This should display the source code always in the same window when debugging.
Found on [[https://stackoverflow.com/questions/39762833/emacsgdb-customization-how-to-display-source-buffer-in-one-window][Stack Overflow]].
#+BEGIN_SRC emacs-lisp
  ; This unfortunately also messes up the regular frame navigation of source code.
  ;(add-to-list 'display-buffer-alist
  ;             (cons 'cdb-source-code-buffer-p
  ;                   (cons 'display-source-code-buffer nil)))

  (defun cdb-source-code-buffer-p (bufName action)
    "Return whether BUFNAME is a source code buffer."
    (let ((buf (get-buffer bufName)))
      (and buf
           (with-current-buffer buf
             (derived-mode-p buf 'c++-mode 'c-mode 'csharp-mode 'nxml-mode)))))

  (defun display-source-code-buffer (sourceBuf alist)
    "Find a window with source code and set sourceBuf inside it."
    (let* ((curbuf (current-buffer))
           (wincurbuf (get-buffer-window curbuf))
           (win (if (and wincurbuf
                         (derived-mode-p sourceBuf 'c++-mode 'c-mode 'nxml-mode)
                         (derived-mode-p (current-buffer) 'c++-mode 'c-mode 'nxml-mode))
                    wincurbuf
                  (get-window-with-predicate
                   (lambda (window)
                     (let ((bufName (buffer-name (window-buffer window))))
                       (or (cdb-source-code-buffer-p bufName nil)
                           (assoc bufName display-buffer-alist)
                           ))))))) ;; derived-mode-p doesn't work inside this, don't know why...
      (set-window-buffer win sourceBuf)
      win))
#+END_SRC


Here is my cheatsheet for the keyboard commands:

All prefixed with =C-x C-a=

|------------+----------------------+---------|
| Domain     | Command              | C-<key> |
| <l>        | <l>                  |   <c>   |
|------------+----------------------+---------|
| Breakpoint | set                  |    b    |
|            | temporary            |    t    |
|            | delete               |    d    |
|------------+----------------------+---------|
| Execute    | Next                 |    n    |
|            | Step Into            |    s    |
|            | Return / Finish      |    f    |
|            | Continue (run)       |    r    |
|------------+----------------------+---------|
| Stack      | Up                   |    <    |
|            | Down                 |    >    |
|------------+----------------------+---------|
| Execute    | Until current line   |    u    |
| (rarer)    | Single instruction   |    i    |
|            | Jump to current line |    j    |
|------------+----------------------+---------|
** editing
*** yasnippet

Let's first see how far I get with file-based capture templates and yankpad.
Install and config by [[https://www.reddit.com/r/emacs/comments/8vdhb4/tip_how_to_integrate_snippets_with_yasnippets/][reddit post]]:

#+BEGIN_SRC emacs-lisp

  (use-package yasnippet
    :defer 1
    :diminish yas-minor-mode
    :config (yas-global-mode))

  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

  ;; (yas-reload-all)
  (yas-global-mode 1)
#+END_SRC

Add a hydra:

#+begin_src emacs-lisp
  (use-package hydra
    :defer 2
    :bind ("C-c y" . hydra-yasnippet/body))

  (defhydra hydra-yasnippet (:color blue)
    "
    ^
    ^YASnippet^          ^Do^
    ^─────────^──────────^──^────────
    _q_ quit             _i_ insert
    ^^                   _m_ mode
    ^^                   _n_ new
    ^^                   ^^
    "
    ("q" nil)
    ("i" yas-insert-snippet)
    ("m" yas-minor-mode)
    ("n" yas-new-snippet))
#+end_src

*** diffing
[[https://github.com/justbur/emacs-vdiff][
vdiff]] let's one compare buffers or files.

#+BEGIN_SRC emacs-lisp
  (use-package vdiff
    :ensure t
    :config
    ; This binds commands under the prefix when vdiff is active.
    (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map))
#+END_SRC

*** commenting out
Easy commenting out of lines.

#+BEGIN_SRC emacs-lisp
  (autoload 'comment-out-region "comment" nil t)
  (global-set-key (kbd "C-c q") 'comment-out-region)
#+END_SRC

*** deduplicate and sort
Help cleanup the includes and using lists.
[[http://www.emacswiki.org/emacs/DuplicateLines][found here]]

#+BEGIN_SRC emacs-lisp
  (defun uniquify-region-lines (beg end)
    "Remove duplicate adjacent lines in region."
    (interactive "*r")
    (save-excursion
      (goto-char beg)
      (while (re-search-forward "^\\(.*\n\\)\\1+" end t)
        (replace-match "\\1"))))

  (defun paf/sort-and-uniquify-region ()
    "Remove duplicates and sort lines in region."
    (interactive)
    (sort-lines nil (region-beginning) (region-end))
    (uniquify-region-lines (region-beginning) (region-end)))
#+END_SRC


Simplify cleanup of =#include= / =typedef= / =using= blocks.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-x s") 'paf/sort-and-uniquify-region)
#+END_SRC

*** selective display (default: off)
Will fold all text indented more than the position of the cursor at
the time the keys are pressed.

#+BEGIN_SRC emacs-lisp :tangle no
(defun set-selective-display-dlw (&optional level)
  "Fold text indented more than the cursor.
   If level is set, set the indent level to level.
   0 displays the entire buffer."
  (interactive "P")
  (set-selective-display (or level (current-column))))

(global-set-key "\C-x$" 'set-selective-display-dlw)
#+END_SRC

*** hightlight-indent-guide-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
#+END_SRC

*** folding by indent level

This is very useful when browsing long yaml such as heml's values.

#+begin_src emacs-lisp
(use-package origami
  :bind ("C-c h o" . hydra-origami/body)
  :config

 (defhydra hydra-origami(:color red)
   "
  _o_pen node    _n_ext fold       toggle _f_orward  _s_how current only
  _c_lose node   _p_revious fold   toggle _a_ll
  "
   ("o" origami-open-node)
   ("c" origami-close-node)
   ("n" origami-next-fold)
   ("p" origami-previous-fold)
   ("f" origami-forward-toggle-node)
   ("a" origami-toggle-all-nodes)
   ("s" origami-show-only-node))
)

#+end_src

** IRC
Use =circe=.
#+BEGIN_SRC emacs-lisp
  (use-package
    circe
      :ensure
      :config(
      setq circe-network-options '((
      "Freenode" :tls t
      :nick "fengxia41103"
      :channels ("#emacs"
      "#python"
      "#odoo"
      "#reactjs"
      "#latex")))))
  (use-package
    helm-circe

    :ensure
    :config)
#+END_SRC

** restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure)
#+END_SRC


Then wrap it w/ this, you can then embed restcall in org!

#+BEGIN_SRC emacs-lisp
(load-file "~/workspace/3rd/ob-restclient.el/ob-restclient.el")
(require 'ob-restclient)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((restclient . t)))
#+END_SRC

** lsp

#+begin_src emacs-lisp
  (use-package lsp-mode
    :init
    ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
    (setq lsp-keymap-prefix "C-c l")
    :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
           (XXX-mode . lsp)
           ;; if you want which-key integration
           (lsp-mode . lsp-enable-which-key-integration))
    :commands lsp)

  (use-package lsp-mode
    :ensure t
    :defer t
    :init
    (setq lsp-keymap-prefix "C-c l")
    :hook ((css-mode-hook . lsp-deferred)
           (html-mode-hook . lsp-deferred)
           (web-mode-hook . lsp-deferred)
           (js2-mode-hook . lsp-deferred)
           (c++-mode-hook . lsp-deferred)
           (c-mode-hook . lsp-deferred)
           (java-mode-hook . lsp-deferred)
           (lsp-mode-hook . lsp-enable-which-key-integration))
    :commands (lsp lsp-deferred)
    :bind (:map lsp-mode-map
                ("M-<RET>" . lsp-execute-code-action)))

  (use-package lsp-ui
    :ensure t
    :defer t
    :config
    (setq lsp-ui-sideline-enable nil)
    :hook (lsp-mode-hook . lsp-ui-mode)
    :bind (:map lsp-ui-mode-map
                ("C-c i" . lsp-ui-imenu)))

  ;; LSP integration with treemacs

  (use-package lsp-treemacs
    :ensure t
    :defer t
    :after lsp)

  ;; Debugger

  ;; (use-package dap-mode
  ;;   :ensure t
  ;;   :defer t
  ;;   :after lsp-mode
  ;;   :config
  ;;   (dap-auto-configure-mode)
  ;;   :bind (:map dap-mode-map
  ;;               ("C-c C-c" . dap-java-debug)
  ;;               ("C-c R" . dap-java-run-test-class)
  ;;               ("C-c d" . dap-java-debug-test-method)
  ;;               ("C-c r" . dap-java-run-test-method)))

  ;; Requires lsp-mode

  (use-package lsp-java
    :ensure t
    :defer t
    :after lsp
    :config
    (setq lsp-java-format-on-type-enabled nil)
    (defun my/java-mode-hook ()
      (setq c-basic-offset 2
            c-label-offset 0
            tab-width 2
            indent-tabs-mode nil
            require-final-newline nil))
    :hook (java-mode-hook . (lsp my/java-mode-hook)))

  ;; Requires dap-mode

  ;; (use-package dap-java
  ;;   :ensure nil
  ;;   :defer t
  ;;   :after (lsp-java))
#+end_src

** languages

These are minor modes to handle programming language specifics which
are often termed as development rules agreed by the team.
*** markdown
Enough to handle my Markdown needs.

#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
    :ensure
    :config)

  (use-package
    markdown-mode

    :ensure
    :config
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)
    (add-hook 'markdown-mode-hook
              (lambda ()
                (visual-line-mode t)
                (writegood-mode t)
                (auto-fill-mode t)
                (flyspell-mode t)))))
#+END_SRC

Tweak the section header fonts a bit:

#+BEGIN_SRC emacs-lisp :tangle no

(let* ((variable-tuple
          (cond ((x-list-fonts "ETBembo")         '(:font "ETBembo"))
                ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana")         '(:font "Verdana"))
                ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (headline           `(:inherit default :weight bold :foreground "#F5F5F5")))

(custom-set-faces
 '(markdown-header-face ((t (,@headline ,@variable-tuple :height 1.0))))
 '(markdown-header-face-1 ((t (,@headline ,@variable-tuple :height 1.3)))
 '(markdown-header-face-2 ((t (,@headline ,@variable-tuple :height 1.2 :foreground "#8BC34A"))))
 '(markdown-header-face-3 ((t (,@headline ,@variable-tuple :height 1.1 :foreground "#FEB236"))))
)
#+END_SRC

Set more markdown faces:

#+BEGIN_SRC emacs-lisp
  (custom-theme-set-faces
   'user
   '(markdown-code-face ((t (:background "gray10"))))
  )
#+END_SRC

*** C/C++
**** header/implementation toggle

Switch from header to implementation file quickly.
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda ()
            (local-set-key  (kbd "C-c o") 'ff-find-other-file)))
#+END_SRC

**** no indentation of namespaces in C++
Essentially, use the Google C++ style formatting.
#+BEGIN_SRC emacs-lisp
  (use-package google-c-style
    :ensure t
    :config
    (add-hook 'c-mode-common-hook 'google-set-c-style)
    (add-hook 'c-mode-common-hook 'google-make-newline-indent))

#+END_SRC

*** python

Setup an IDE:

#+BEGIN_SRC emacs-lisp :tangle no
(use-package elpy
  :ensure t
  :init
  (elpy-enable))
#+END_SRC


ELPY has its own indentation mode, which is overriding the one I use
globally, so disable this one:

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1)))
#+END_SRC


Link to yasnippet mode:
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'elpy-mode-hook #'yas-minor-mode)
#+END_SRC


Auto black on save:
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'elpy-black-fix-code nil t)
#+END_SRC


Force UTF-8 encoding. Otherwise, elpy will complain w/ some exit 1 abnormal
error.

#+BEGIN_SRC emacs-lisp
(setenv "PYTHONIOENCODING" "utf-8")
(add-to-list 'process-coding-system-alist '("python" . (utf-8 . utf-8)))
(add-to-list 'process-coding-system-alist '("elpy" . (utf-8 . utf-8)))
(add-to-list 'process-coding-system-alist '("flake8" . (utf-8 . utf-8)))
#+END_SRC


And set up virtualenv path:
#+BEGIN_SRC emacs-lisp :tangle no
;; workon home
(setenv "WORKON_HOME" "/home/fengxia/workspace/me/python-venv/")
(setq elpy-rpc-virtualenv-path 'current)
#+END_SRC

Add [[https://github.com/naiquevin/sphinx-doc.el][sphinx-doc]] to generate docstrings:
#+begin_src emacs-lisp
(use-package sphinx-doc
  :ensure t)
(add-hook 'python-mode-hook (lambda ()
                              (require 'sphinx-doc)
                              (sphinx-doc-mode t)))
#+end_src

**** auto-virtualenv

#+BEGIN_SRC
(use-package auto-virtualenv
  :ensure t
  :init
  (use-package pyvenv
    :ensure t)
  :config
  (add-hook 'python-mode-hook 'auto-virtualenv-set-virtualenv)
  (add-hook 'projectile-after-switch-project-hook 'auto-virtualenv-set-virtualenv)
  )
#+END_SRC

**** py-autopep8

Add hook to reformat python code based on pep8 spec. You need to
install =pip install autopep8= offline.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package
    py-autopep8
    :ensure)
  (add-hook 'python-mode-hook 'py-autopep8-enable-on-save)
  (setq py-autopep8-options '("--max-line-length=88"))
#+END_SRC


#+RESULTS:
| --max-line-length=79 |

**** py-isort
Sort python import. Need to install =pip install isort= offline.

#+BEGIN_SRC emacs-lisp
  (use-package
    py-isort

    :ensure
    :config
    (add-hook 'before-save-hook 'py-isort-before-save)
    (setq py-isort-options '("-sl --profile black --filter-files")))
#+END_SRC

**** imenu-list

#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
  :ensure)
#+END_SRC

**** smartparens
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook #'smartparens-mode)
#+END_SRC

**** python-black

I installed ~black~ using ~apt install black~ because my default
virtualenv is still on python 2.7. If you have 3.x, you should follow
their [[https://github.com/psf/black][official instruction]]. Anyway, I think either should be fine.

Now use the emacs wrapper:

#+BEGIN_SRC emacs-lisp
(use-package python-black
  :ensure)
#+END_SRC

**** sphinx-doc

Creat [[https://github.com/naiquevin/sphinx-doc.el][sphinx doc]] string from function definition directly.

#+BEGIN_SRC emacs-lisp

(use-package sphinx-doc
  :ensure)
  (add-hook 'python-mode-hook (lambda ()
  (require 'sphinx-doc)
  (sphinx-doc-mode t)))
#+END_SRC

*** web-mode
web-mode with config for Polymer editing
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (setq web-mode-enable-current-element-highlight t)
    (setq web-mode-enable-current-column-highlight t)
    (setq web-mode-enable-css-colorization t))
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
#+END_SRC


Who should use this mode:
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.ftl\\'" . web-mode))
#+END_SRC

This is actually depending on =js-beautify=. See [[https://github.com/yasuyk/web-beautify][web-beautify]] for
details.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package web-beautify
    :ensure
    :config)
  ;; (add-hook 'js2-mode-hook
  ;;           (lambda ()
  ;;             (add-hook 'before-save-hook 'web-beautify-js-buffer t t)))
  ;; (add-hook 'json-mode-hook
  ;;           (lambda ()
  ;;             (add-hook 'before-save-hook 'web-beautify-js-buffer t t)))
  (add-hook 'web-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'web-beautify-html-buffer t t)))
  ;; (add-hook 'css-mode-hook
  ;;           (lambda ()
  ;;             (add-hook 'before-save-hook 'web-beautify-css-buffer t t)))
  (add-hook 'html-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'web-beautify-html-buffer t t)))
#+END_SRC

*** [[https://github.com/smihica/emmet-mode][emmet-mode]]

Useful abbreviations when coding in HTML. See [[https://github.com/rooney/zencoding][zencoding]] for details.

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :after(web-mode css-mode scss-mode)
    :config)
  (setq emmet-expand-jsx-className? t)
  (setq emmet-move-cursor-between-quotes t)
  (add-hook 'emmet-mode-hook (lambda () (setq emmet-indent-after-insert nil)))
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'web-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook  'emmet-mode)
  (add-hook 'scss-mode-hook  'emmet-mode)
#+END_SRC

*** javascript family: .js .ts .jsx
There are a couple packages for .js files.

**** js2-mode
First, use =js2-mode= to handle =.js= and =.jsx= files.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure
    :config)
  (setq js2-indent-level 2)
  (add-to-list 'auto-mode-alist '("\\.js[x]\\'" . js2-mode))
  (add-to-list 'auto-mode-alist '("\\.ts[x]\\'" . js2-mode))
  (add-hook 'js2-mode-hook #'smartparens-mode)
  (add-hook 'js2-mode-hook #'(lambda () (setq-local electric-indent-inhibit t)))
#+END_SRC

**** prettier
Link js2-mode to prettier to beautify my code.
Follow [[https://github.com/jscheid/prettier.el][official site]] to install and config.

Set which prettier to use. Note that w/ NVM, you must set =nvm use 16.15.1= in
=.bashrc= or =.zshrc= so that shell will use the right path, also. You can check
which is the default node path in effect in Emacs by =M-x prettier-info=.

#+begin_src emacs-lisp :tangle no
(setenv "NODE_PATH" "/home/fengxia/.nvm/versions/node/v16.15.1/bin")
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package prettier
    :ensure
    :config)
  (add-hook 'js2-mode-hook 'prettier-mode)
  (add-hook 'json-mode-hook 'prettier-mode)
  (add-hook 'js-mode-hook 'prettier-mode)
  (setq indent-tabs-mode nil js-indent-level 2)
  (add-hook
   'js2-mode-hook
   (lambda ()
     (when (string-match "\\.[tj]sx?$" buffer-file-name)
       (setq-local prettier-parsers '(typescript)))))
#+END_SRC

**** js-doc
Nothing is complete without a doc solution.

#+BEGIN_SRC emacs-lisp
(use-package js-doc
  :ensure
  :config
  (setq js-doc-mail-address "feng.xia@mycompany.io")
  (setq js-doc-author (format "Feng Xia <%s>" js-doc-mail-address))
  (setq js-doc-url "http://www.mycompany.com")
  (setq js-doc-license "Company License")
)
(add-hook 'js2-mode-hook
          #'(lambda ()
              (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
              (define-key js2-mode-map "@" 'js-doc-insert-tag)))

#+END_SRC

*** csv
mode to edit CSV files.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package csv-mode
    :ensure t
    :mode "\\.csv\\'")
#+END_SRC

*** json

This should be installed before the javascript stuff because I'll be
using the =prettier= as beautifier.

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure
    :config)
#+END_SRC

*** yaml

Details are [[https://github.com/yoshiki/yaml-mode][here]].

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure
    :config)
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
  (add-hook 'yaml-mode-hook
            '(lambda ()
          (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC

Add [[https://github.com/iquiw/lsp-yaml][lsp-yaml]]:

#+begin_src emacs-lisp
(use-package lsp-yaml
  :after lsp
  :config
  (add-hook 'yaml-mode-hook #'lsp))
#+end_src

*** jenkins

#+BEGIN_SRC emacs-lisp
  (use-package jenkinsfile-mode
    :ensure
    :config)

#+END_SRC

*** SQL

I guess I would have to deal w/ SQL eventually. See the [[https://github.com/purcell/sqlformat][instructions here]]. You
need to install =apt install pgformatter= offline.

#+begin_src emacs-lisp
  (use-package sqlformat
    :ensure
    :config)
#+end_src

If using =pg_format=, set the configs:

#+begin_src emacs-lisp
(setq sqlformat-command 'pgformatter)
(setq sqlformat-args '("-s4" "-B" "-w150" "-k" "-f2" "-U2" "--extra-keyword=/home/fengxia/workspace/tmp/oracle-keywords"))
#+end_src

If using =sqlformat=, set the configs:
#+begin_src emacs-lisp :tango no
(setq sqlformat-command 'sqlformat)
(setq sqlformat-args '("-k" "upper" "-i" "upper" "-s" "-r" "--indent_width=4"))
#+end_src

And define a keybind for formatting:

#+begin_src emacs-lisp
(add-hook 'sql-mode-hook '(lambda()
  (define-key sql-mode-map (kbd "C-c C-f") 'sqlformat-buffer)))
#+end_src

*** Microsoft DAX

Load the =dax-mode= by [[https://github.com/fpvmorais/dax-mode/tree/master][github]]:

#+begin_src emacs-lisp
(load "~/.emacs.d/dax-mode/dax-mode.el")
#+end_src


Add a formatter function by the [[https://fpvmorais.com/post/emacs-major-modes-for-power-bi/][blog]]:

#+begin_src emacs-lisp
(defun dax-pretty-print ()
  "Pretty print the DAX buffer via DaxFormatter API."
  (interactive)
  (goto-char (point-min))
  (while (search-forward ";" nil t)
    (replace-match ","))
  (goto-char (point-min))
  (setq payload (make-hash-table))
  (setf (gethash "Dax" payload) `(delete-and-extract-region (point-min) (point-max)))
  (setf (gethash "l" payload) "short")
  (let* (
         (url-request-method "POST")
         (url-request-extra-headers '(("Content-Type" . "application/json")))
         (url-request-data (json-encode `(("Dax" ., (delete-and-extract-region (point-min) (point-max)) ))))
         ;; (url-request-data (json-encode ,payload))
         (buf (current-buffer))
         (newbuff (url-retrieve-synchronously "http://www.daxformatter.com/api/daxformatter/DaxFormat/"))
         )
    (set-buffer newbuff)
    (goto-char (point-min))
    (re-search-forward "^$")
    (delete-region (point) (point-min))
    (setq noQuotes (substring (buffer-string) 1 nil))
    (setq noRN (replace-regexp-in-string "\r\n" "\n" noQuotes))
    (setq noBars (replace-regexp-in-string "\\\\" "" noRN))
    (princ noBars buf)
    (kill-buffer newbuff)
    )
  )
#+end_src

Last, define a keyboard bind for formatting:

#+begin_src emacs-lisp :tangle no

(add-hook dax-mode-hook '(lambda()
  (define-key sql-mode-map (kbd "C-c C-f") 'dax-pretty-print)))

#+end_src

*** Terraform

#+begin_src emacs-lis
  (use-package terraform-mode
    :ensure
    :config)
(add-hook 'terraform-mode-hook #'outline-minor-mode)
(setq terraform-format-on-sav t)
#+end_src

*** Java

Ah, the one language I promised myself not to learn. But finally, I read about
Java and Spring. It's just, that.

#+begin_src emacs-lisp
  (use-package lsp-java
    :after java
    :config
    (add-hook 'java-mode-hook #'lsp))
#+end_src

Some additional packages according to [[https://github.com/emacs-lsp/lsp-java][this]]:

#+begin_src emacs-lisp
  (use-package projectile)
  (use-package flycheck)
  (use-package lsp-mode :hook ((lsp-mode . lsp-enable-which-key-integration)))
  (use-package company)
  (use-package lsp-ui)
  (use-package which-key :config (which-key-mode))
  (use-package dap-mode :after lsp-mode :config (dap-auto-configure-mode))
  (use-package dap-java :ensure nil)
  (use-package lsp-treemacs)
#+end_src

**** lombok

#+begin_src emacs-lisp
  ;;; lsp-java-lombok.el --- Description -*- lexical-binding: t; -*-
  ;;
  ;; Copyright (C) 2021 Kevin Ziegler
  ;;
  ;; Author: Kevin Ziegler <https://github.com/kevinziegler>
  ;; Maintainer: Kevin Ziegler
  ;; Created: February 12, 2021
  ;; Modified: February 12, 2021
  ;; Version: 0.0.1
  ;; Homepage: https://github.com/kevinziegler/lsp-java-lombok
  ;; Package-Requires: ((emacs "24.3"))
  ;;
  ;; This file is not part of GNU Emacs.
  ;;
  ;;; Commentary:
  ;;  Helper library for setting up Lombok with LSP-java
  ;;
  ;;; Code:
  (require 'lsp-java)

  (defvar lsp-java-lombok/enabled nil
    "Indicates the LSP server should be started with Lombok.")

  (defvar lsp-java-lombok/version nil
    "When non-nil, use the specified Lombok version, otherwise use the latest.")

  (defvar lsp-java-lombok/jar-url-base "https://projectlombok.org/downloads/"
    "The base path to download Lombok jars from.")

  (defvar lsp-java-lombok/dir user-emacs-directory
    "The path on disk where lombok jars are saved.")

  (defun lsp-java-lombok/jar-file ()
    "Get the filename for the Lombok jar."
    (concat "lombok"
            (when lsp-java-lombok/version "-")
            lsp-java-lombok/version
            ".jar"))

  (defun lsp-java-lombok/jar-path ()
    "Generate the path on disk for the Lombok jar."
    (concat user-emacs-directory (lsp-java-lombok/jar-file)))

  (defun lsp-java-lombok/download-jar ()
    "Download the latest lombok jar for use with LSP."
    (let* ((lombok-url (url-generic-parse-url lsp-java-lombok/jar-url-base))
           (base-path (file-name-as-directory (url-filename lombok-url)))
           (file-path (concat base-path (lsp-java-lombok/jar-file))))
      (setf (url-filename lombok-url) file-path)
      (url-copy-file lombok-url (lsp-java-lombok/jar-path))))

  (defun lsp-java-lombok/append-vmargs ()
    "Apply lombok args to lsp-java-vmargs."
    (setq lsp-java-vmargs
          (append lsp-java-vmargs
                  (concat "-javaagent:" (lsp-java-lombok/jar-path)))))

  (defun lsp-java-lombok/setup ()
    "Download Lombok if it hasn't been downloaded already."
    (when (not (file-exists-p (lsp-java-lombok/jar-path)))
      (message "Could not find lombok for lsp-java.  Downloading...")
      (lsp-java-lombok/download-jar)))

  (defun lsp-java-lombok/init ()
    "Initialize lsp-java-lombok."
    (when lsp-java-lombok/enabled
      (lsp-java-lombok/setup)
      (lsp-java-lombok/append-vmargs)))

  (provide 'lsp-java-lombok)
  ;;; lsp-java-lombok.el ends here

#+end_src

** LAST: enforce my tab style

Found this [[https://github.com/syl20bnr/spacemacs/issues/5923][here]], and I like it, to set my styles in a central
location. This was researched while battling the .js tab level. I
don't want to use the =customize= way since that will be a hidden
manual step after a fresh install.

First, define a func to include my indent settings. It takes an input
argument:

#+BEGIN_SRC emacs-lisp
    (defun my-setup-indent (n)
      ;; java/c/c++
      (setq-local standard-indent n)
      (setq-local c-basic-offset n)

      ;; javascript family
      (setq-local javascript-indent-level n) ; javascript-mode
      (setq-local js-indent-level n) ; js-mode
      (setq-local js2-basic-offset n) ; js2-mode
      (setq-local js-switch-indent-offset n) ; js-mode
      (setq-local javascript-indent-level n) ; javacript-mode
      (setq-local react-indent-level n) ; react-mode
      (setq-local js2-basic-offset n)

      ;; html, css
      (setq-local web-mode-attr-indent-offset n) ; web-mode
      (setq-local web-mode-code-indent-offset n) ; web-mode, js code in html file
      (setq-local web-mode-css-indent-offset n) ; web-mode, css in html file
      (setq-local web-mode-markup-indent-offset n) ; web-mode, html tag in html file
      (setq-local web-mode-sql-indent-offset n) ; web-mode
      (setq-local web-mode-attr-value-indent-offset n) ; web-mode
      (setq web-mode-comment-style 2) ;; web-mode
      (setq-local css-indent-offset n) ; css-mode

      ;; shells
      (setq-local sh-basic-offset n) ; shell scripts
      (setq-local sh-indentation n))
#+END_SRC


Now set the tabs:

#+BEGIN_SRC emacs-lisp
  (defun my-personal-code-style ()
    (interactive)
    (message "My personal code style!")
    ;; use space instead of tab
    (setq indent-tabs-mode nil)
    ;; indent 2 spaces width
    (my-setup-indent 2))

  ;; it would be lovely if this was enough, but it gets stomped on by modes.
  (my-personal-code-style)
#+END_SRC


So, to enfore this on some modes:
#+BEGIN_SRC emacs-lisp
  (add-hook 'css-mode-hook 'my-personal-code-style)
  (add-hook 'js2-mode-hook 'my-personal-code-style)
  (add-hook 'react-mode-hook 'my-personal-code-style)
  (add-hook 'sh-mode-hook 'my-personal-code-style)
  (add-hook 'groovy-mode-hook 'my-personal-code-style)
#+END_SRC

* Buffers

There are three concepts seem to me: desktop, window config, and buffers.

- desktop: is like virtual desktop, and you can have many, like i3.
- window config: think of it like a look you have created using
  buffers, eg. stack them this way or that way, on the same
  desktop. So switching a window config will switch the buffer layout
  within your current desktop.
- buffer: is the building block.

** by packages
*** multi desktops: eyebrowse

Awesome window manager. It's like using i3m but inside emacs. Use the
=C-c C-w <0..9>= key to switch to so called desktop. On each desktop,
you can have different buffers open and so on, so I don't have to
close buffers, or =C-x b= a lot anymore. Look for details [[https://depp.brause.cc/eyebrowse/][here]].

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t)
(eyebrowse-mode t)
#+END_SRC

*** select buffer

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure
    :config
    (setq aw-ignore-current t)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-minibuffer-flag nil)
    (setq aw-background t)
    (global-set-key (kbd "C-x C-o") 'ace-window)
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground
       :foreground "#D52349"
       :height 1000
       :overline t
       :box nil)))))
  )
#+END_SRC


#+RESULTS:
: t

*** buffer naming
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :init
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

** save & restore buffers

First, you need to create a folder =~/.emacs.d/savehist=. If not, upon
existing emacs, it will complain, asking you whether you want to
=ignore= it, answer =yes= will be fine. No harm. It's just the session
will not then be saved.


#+BEGIN_SRC emacs-lisp

  (setq desktop-path (list "~/.emacs.d/savehist"))
  (setq desktop-dirname "~/.emacs.d/savehist")
  (setq desktop-restore-eager 5)
  (setq desktop-load-locked-desktop t)
  (desktop-save-mode 1)

    (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))

#+END_SRC


But skip the followings:
#+BEGIN_SRC emacs-lisp
  (setq desktop-buffers-not-to-save
       (concat "\\("
               "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
               "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
               "\\)$"))
  (add-to-list 'desktop-modes-not-to-save 'dired-mode)
  (add-to-list 'desktop-modes-not-to-save 'Info-mode)
  (add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
  (add-to-list 'desktop-modes-not-to-save 'fundamental-mode)
#+END_SRC


See [[https://github.com/thierryvolpiatto/psession][here]]:

#+BEGIN_SRC emacs-lisp
  (use-package psession
    :ensure)
  (psession-mode 1)
  (psession-savehist-mode 1)
  (psession-autosave-mode 1)
#+END_SRC

** switch window config: winner-mode

Read [[https://www.emacswiki.org/emacs/WinnerMode][here]]. A config is essentially a look of buffers, and there can be
many, say, a config has two windows side by side, while another is 3
stacked. This mode will let you switch between them on the same desktop.

Enables =winner-mode=. Navigate buffer-window configs with =C-c left= and
=C-c right=.

#+BEGIN_SRC emacs-lisp :tangle no
  (winner-mode 1)
#+END_SRC


However, with eyebrowse, I think this is redundant function. Maybe I should skip
this?

** toggle maximize buffer

Temporarily maximize a buffer.  [[https://gist.github.com/mads379/3402786][found here]]

#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-buffer () "Maximize buffer"
  (interactive)
  (if (= 1 (length (window-list)))
      (jump-to-register '_)
    (progn
      (window-configuration-to-register '_)
      (delete-other-windows))))
#+END_SRC


Map it to a key.

#+BEGIN_SRC emacs-lisp
  (global-set-key [M-f8] 'toggle-maximize-buffer)
#+END_SRC

** buffer decorations
Setup the visual cues about the current editing buffer
#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
  (setq visible-bell t)
  (setq scroll-step 1)
  (setq-default transient-mark-mode t)  ;; highlight selection
#+END_SRC

* Editing

The heart of editor is, well, editing. Many things are determining the
experience. Here are the ones I use to make editing quicker, easier,
less typing essentially.

** by packages
*** auto company

A good auto completion thing. See details [[https://company-mode.github.io/][here]].

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config)
(add-hook 'prog-mode-hook 'global-company-mode)
#+END_SRC

*** undo tree

More [[https://elpa.gnu.org/packages/undo-tree.html][undos]]?

#+BEGIN_SRC emacs-lisp :tangle no
    ;; (use-package undo-tree
    ;;   :ensure t
    ;;   :config
    ;;   (setq undo-tree-visualizer-timestamps t)
    ;;   (setq undo-tree-visualizer-diff t))
    ;; (global-undo-tree-mode)

  (use-package undo-tree
    :defer t
    :diminish undo-tree-mode
    :init (global-undo-tree-mode)
    :custom
    (undo-tree-visualizer-diff t)
    (undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
    (undo-tree-visualizer-timestamps t))
#+END_SRC

*** search & jump
**** ag
Use the silversearcher.
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure
    :config
    (setq ag-highlight-search t)
    (setq ag-reuse-buffers t))
#+END_SRC


Follow the [[https://github.com/emacsorphanage/helm-ag][helm-ag manual]], "Insert thing at point as default search
pattern, if this value is non nil":

#+BEGIN_SRC emacs-lisp
  (setq helm-ag-insert-at-point 'symbol)
  (setq helm-ag-use-temp-buffer t)
#+END_SRC

**** dumb-jump

First, let's make sure we have =xref= because we will hook into the
xref backend:

#+BEGIN_SRC emacs-lisp
  (use-package xref
    :ensure
    :config)
#+END_SRC


Now install =dumb-jump=:

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure
    :config
    (setq dumb-jump-prefer-searcher 'ag))
#+END_SRC


Some hydra:
#+BEGIN_SRC emacs-lisp
(defhydra dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump"
    ("j" dumb-jump-go "Go")
    ("o" dumb-jump-go-other-window "Other window")
    ("e" dumb-jump-go-prefer-external "Go external")
    ("x" dumb-jump-go-prefer-external-other-window "Go external other window")
    ("i" dumb-jump-go-prompt "Prompt")
    ("l" dumb-jump-quick-look "Quick look")
    ("b" dumb-jump-back "Back"))
#+END_SRC


Last, hook to =xref= to use =M.= bind:

#+BEGIN_SRC emacs-lisp
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
#+END_SRC

**** ripgrep
This enables searching recursively in projects.

#+BEGIN_SRC emacs-lisp
  (use-package ripgrep
    :ensure t)
  (use-package projectile-ripgrep
    :ensure t
    :requires (ripgrep projectile))
#+END_SRC

*** max 80 cols wide
#+BEGIN_SRC emacs-lisp
  (use-package column-enforce-mode
    :ensure t
    :config
    (setq column-enforce-column 80)
    :bind ("C-c m" . 'column-enforce-mode))
  ;; column-enforce-face
#+END_SRC

*** highlight whitespace & lines > 80 long

Highlight unnecessary chars and lines over 80.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package whitespace
  :ensure
  :config (setq whitespace-style '(face empty tabs lines-tail trailing))
  :config (global-whitespace-mode t))
#+END_SRC

*** browse kill ring

Don't use =popup-kill-ring= as it's dead. Use the [[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]]:

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :ensure
    :config
    (setq browse-kill-ring-highlight-current-entry t)
    (setq browse-kill-ring-highlight-inserted-item t))

  (browse-kill-ring-default-keybindings)
#+END_SRC

*** parenthesis

Borrowing from old init.el:

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(set-face-attribute 'region nil
                    :background "#666"
                    :foreground "#d52349")
(set-face-background 'show-paren-match (face-background 'default))
(set-face-foreground 'show-paren-match "#d52349")
(set-face-attribute 'show-paren-match nil
                    :weight 'extra-bold)
#+END_SRC

**** show matching delimiters (default: on)

Use [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiter]]. Do not set the
=rainbow-delimiters-mismatched-face= because it will raise alarm all all
the following brackets when there is a mismatch, like a xmas lights,
and it's distracting to find out the actual mismatch!

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure
    :config
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :background "GhostWhite"))
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+END_SRC

**** type using smartparens (default: on)

Well, who wants to type parenthesis.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure
    :config
    (require 'smartparens-config))
  (add-hook 'prog-mode-hook #'smartparens-mode)
#+END_SRC

*** string inflection (default: some modes)

This is useful in coding to change a string to snake, camel and so on.

#+BEGIN_SRC emacs-lisp
  (use-package string-inflection
    :ensure
    :config)
  (add-hook 'python-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-q C-u")
                                'string-inflection-python-style-cycle)))
  (add-hook 'org-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-q C-u")
                                'string-inflection-python-style-cycle)))
  (add-hook 'mu4e-compose-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-q C-u")
                                'string-inflection-python-style-cycle)))
  (add-hook 'js2-mode-hook
              '(lambda ()
                 (local-set-key (kbd "C-q C-u")
                                'string-inflection-python-style-cycle)))
  #+END_SRC

*** annotate-mode (default: some modes)

The file-annotations are store externally. Seems to fail with
=args-out-of-range= and then Emacs is confused. (filed issue for this)

Also, it seems to interfere with colorful modes like =magit= or
=org-agenda-mode= so that I went with a whitelist instead of the wish of
a blacklist of modes.

Read more [[https://github.com/bastibe/annotate.el][here]].

#+BEGIN_SRC emacs-lisp
  (use-package annotate
    :ensure t

    ;; for ledger-mode, as 'C-c C-a' is taken there.
    :bind ("C-c C-A" . 'annotate-annotate)

    :config
    (add-hook 'org-mode 'annotate-mode)
    (add-hook 'csv-mode 'annotate-mode)
    (add-hook 'c-mode 'annotate-mode)
    (add-hook 'c++-mode 'annotate-mode)
    (add-hook 'sh-mode 'annotate-mode)
  ;;;  (define-globalized-minor-mode global-annotate-mode annotate-mode
  ;;;    (lambda () (annotate-mode 1)))
  ;;;  (global-annotate-mode 1)
    )
#+END_SRC

*** writeroom-mode (default: off)

It seems to be a particular way of changing the buffer look so the
writer can focus on, writing. Read [[https://github.com/joostkremers/writeroom-mode][more here]].

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :ensure t
    :config)
#+END_SRC

*** anzu

Show number of search matches.

#+BEGIN_SRC emacs-lisp
  (use-package
    anzu

    :ensure
    :config)
  (global-anzu-mode +1)
#+END_SRC

*** move-text

Looks convenient [[https://github.com/emacsfodder/move-text][here]]:
- =Meta-up= move-text-up (line or active region)
- =Meta-down= move-text-down (line or active region)

#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure
    :config)
(move-text-default-bindings)
#+END_SRC

*** tabs to 2

These are global tab settings. Since TAB is such a sensitive thing,
each coding mode may have a different style/preference that will
override this.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq require-final-newline t)
  (setq indent-line-function 'insert-tab)
  (setq-default tab-width 2)
#+END_SRC

** no trailing spaces

Delete all trailing white space in the buffer.

#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** iedit mode

Instead of using the string replacement, use this edit mode will
highlight all the occurances in the buffer, and now your editing will
take effect on all of them.

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure)

  (global-set-key (kbd "C-M-i") 'iedit-mode)
#+END_SRC

** ediff

#+begin_src emacs-lisp
(custom-set-variables
 '(ediff-window-setup-function 'ediff-setup-windows-plain)
 '(ediff-diff-options "-w")
 '(ediff-split-window-function 'split-window-horizontally))
#+end_src

* Navigate file & dir

I'm not quite used to using emacs as file manager yet. To me, it's
much easier to just start a shell and type.

Nonetheless, navigating code tree is necessary, and the one like CP is
so deeply buried that having a good navigator is probably a good
thing.

The most dramatic thing is [[#treemacs][treemacs]], which I need some time to get
used to. It looks nice, but feels a bit, exaggerated to my taste.

** dir hack
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure
    :config)

  (use-package dired-hacks-utils
    :ensure
    :config)
#+END_SRC

** dired-rainbow

Make the dired coloful. Copied from [[https://github.com/Fuco1/dired-hacks][dired-hacks]].

#+BEGIN_SRC emacs-lisp
  (use-package dired-rainbow
    :ensure
    :config
    (progn
      (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
      (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
      (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
      (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
      (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
      (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
      (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
      (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
      (dired-rainbow-define log "#c17d11" ("log"))
      (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
      (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
      (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
      (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
      (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
      (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
      (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
      (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
      (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
      (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
      (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
      ))

#+END_SRC

** dired-narrow
#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :ensure
    :config)
#+END_SRC

** dired-collapse

#+BEGIN_SRC emacs-lisp
  (use-package dired-collapse
    :ensure
    :config)
#+END_SRC

** dired-filter

#+BEGIN_SRC emacs-lisp
  (use-package dired-filter
    :ensure
    :config)
#+END_SRC

** treemacs (default: off)
:PROPERTIES:
:CUSTOM_ID: treemacs
:END:

Copied from [[https://github.com/Alexander-Miller/treemacs#installation][here]]. I'm leaving this mode off by default. =C-c t t= to
enable it.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs                 (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay      0.5
            treemacs-directory-name-transformer    #'identity
            treemacs-display-in-side-window        t
            treemacs-eldoc-display                 t
            treemacs-file-event-delay              5000
            treemacs-file-extension-regex          treemacs-last-period-regex-value
            treemacs-file-follow-delay             0.2
            treemacs-file-name-transformer         #'identity
            treemacs-follow-after-init             t
            treemacs-git-command-pipe              ""
            treemacs-goto-tag-strategy             'refetch-index
            treemacs-indentation                   2
            treemacs-indentation-string            " "
            treemacs-is-never-other-window         nil
            treemacs-max-git-entries               5000
            treemacs-missing-project-action        'ask
            treemacs-move-forward-on-expand        nil
            treemacs-no-png-images                 nil
            treemacs-no-delete-other-windows       t
            treemacs-project-follow-cleanup        nil
            treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-position                      'left
            treemacs-recenter-distance             0.1
            treemacs-recenter-after-file-follow    nil
            treemacs-recenter-after-tag-follow     nil
            treemacs-recenter-after-project-jump   'always
            treemacs-recenter-after-project-expand 'on-distance
            treemacs-show-cursor                   nil
            treemacs-show-hidden-files             t
            treemacs-silent-filewatch              nil
            treemacs-silent-refresh                nil
            treemacs-sorting                       'alphabetic-asc
            treemacs-space-between-root-nodes      t
            treemacs-tag-follow-cleanup            t
            treemacs-tag-follow-delay              1.5
            treemacs-user-mode-line-format         nil
            treemacs-user-header-line-format       nil
            treemacs-width                         35
            treemacs-workspace-switch-cleanup      nil)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode t)
      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple))))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
            ("C-x t t"   . treemacs)
            ("C-x t B"   . treemacs-bookmark)
            ("C-x t C-t" . treemacs-find-file)
            ("C-x t M-t" . treemacs-find-tag)))


    (use-package treemacs-icons-dired
      :after treemacs dired
      :ensure t
        :config (treemacs-icons-dired-mode))

    (use-package treemacs-projectile
      :after treemacs projectile
      :ensure t)
    (use-package treemacs-magit
      :after treemacs magit
      :ensure t)
  #+END_SRC


  Add some files to ignore, eg. ~.pyc`:

  #+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'treemacs
      (defun treemacs-ignore-gitignore (file _)
        (string= file ".pyc"))
      (push #'treemacs-ignore-gitignore treemacs-ignored-file-predicates))
  #+END_SRC

* Helm

Helm should really has its own section because it touches everything!

I just took over the config described in this [[https://tuhdo.github.io/helm-intro.html][helm intro]].

#+BEGIN_SRC emacs-lisp
  (use-package helm
   :ensure t
   :delight helm-mode
   :config
    ;; (require 'helm-config)
    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
    (define-key helm-map (kbd "C-M-x") 'helm-execute-persistent-action) ; make TAB work in terminal
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-split-window-inside-p            t ; open helm buffer inside current window, not occupy whole other window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-echo-input-in-header-line t)

    (setq helm-autoresize-max-height 50)
    (setq helm-autoresize-min-height 0)
    (helm-autoresize-mode 1)

    (setq helm-M-x-fuzzy-match t)
    (setq helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match    t)
    (setq helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match    t)
  (setq helm-locate-fuzzy-match t)
  (setq helm-apropos-fuzzy-match t)
  (setq helm-lisp-fuzzy-completion t)
  (helm-mode 1)
  (global-set-key (kbd "C-x C-m") 'helm-M-x))
#+END_SRC


Found [[https://www.reddit.com/r/emacs/comments/30yer0/helm_and_recentf_tips/][this reddit post]] of using =helm-mini=:

#+BEGIN_SRC emacs-lisp
(setq helm-mini-default-sources '(helm-source-buffers-list
                                  helm-source-recentf
                                  helm-source-bookmarks
                                  helm-source-buffer-not-found))
#+END_SRC

* Write chinese
I have been using this one w/ reasonable success.

First, install pyim.

#+BEGIN_SRC emacs-lisp
  (use-package pyim
    :ensure
    :defer 10
    :config

    ;; 五笔用户使用 wbdict 词库
    ;; (use-package pyim-wbdict
    ;;   :ensure nil
    ;;   :config (pyim-wbdict-gbk-enable))

    (setq default-input-method "pyim")

    ;; 我使用全拼
    (setq pyim-default-scheme 'quanpin)

    ;; 设置 pyim 探针设置，这是 pyim 高级功能设置，可以实现 *无痛* 中英文切换 :-)
    ;; 我自己使用的中英文动态切换规则是：
    ;; 1. 光标只有在注释里面时，才可以输入中文。
    ;; 2. 光标前是汉字字符时，才能输入中文。
    ;; 3. 使用 M-j 快捷键，强制将光标前的拼音字符串转换为中文。
    ;; (setq-default pyim-english-input-switch-functions
    ;;               '(pyim-probe-dynamic-english
    ;;                 pyim-probe-isearch-mode
    ;;                 pyim-probe-program-mode
    ;;                 pyim-probe-org-structure-template))

    ;; (setq-default pyim-punctuation-half-width-functions
    ;;               '(pyim-probe-punctuation-line-beginning
    ;;                 pyim-probe-punctuation-after-punctuation))

    ;; 开启拼音搜索功能
    (pyim-isearch-mode 1)

    ;; 使用 pupup-el 来绘制选词框
    (setq pyim-page-tooltip 'popup)

    ;; 选词框显示5个候选词
    (setq pyim-page-length 7)

    ;; 让 Emacs 启动时自动加载 pyim 词库
    (add-hook 'emacs-startup-hook
              #'(lambda () (pyim-restart-1 t)))
    :bind
    (;与 pyim-probe-dynamic-english 配合
    ("M-j" . pyim-convert-code-at-point)

    ("C-;" . pyim-delete-word-from-personal-buffer)))
#+END_SRC


Add a basic dictionary.
#+BEGIN_SRC emacs-lisp
  ;; Basedict
  (use-package pyim-basedict
    :ensure t)
  (pyim-basedict-enable)
#+END_SRC


Last, a couple global settins.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-\\") 'toggle-input-method)
(setq default-input-method "pyim")
#+END_SRC

* Office stuff
Using emacs in a corporate env can be daunting.

** mu4e email
mu4e only a emac client. The workhorse are davmail, isync and mu. You need to install these offline and hook them up using the config below.

*** install & minimal setup
First thing first, load the package. As you can see, I have used =apt-get= install mu4e.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e/")
  (require 'mu4e)
  (require 'mu4e-contrib)
#+END_SRC


Then we load =maildirs-extension=:

#+BEGIN_SRC emacs-lisp
  (use-package mu4e-maildirs-extension
    :ensure
    :config)
  (mu4e-maildirs-extension)
#+END_SRC


Now, we tell emacs I want to use =mu4e= as email client:

#+BEGIN_SRC emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+END_SRC


Link to a couple modes to help me writing good emails:

#+BEGIN_SRC emacs-lisp
  (add-hook 'mu4e-compose-mode-hook
  (lambda ()
  (visual-line-mode t)
  (writegood-mode t)
  (flyspell-mode t)))
  #+END_SRC

*** mu4e-column-faces

I like it! I installed via =list-package= as =C-x C-e= of the block below didn't
work for some reason!

#+begin_src emacs-lisp
  (use-package mu4e-column-faces
    :after mu4e
    :config (mu4e-column-faces-mode))
#+end_src

*** customize face

#+begin_src emacs-lisp
  (custom-set-faces
   '(mu4e-header-highlight-face ((t (:foreground "tomato" :weight bold :overline t :underline t))))
   )
#+end_src

*** context

In 1.8.7 we can setup different [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts-example.html][context]] so we can use the same mu4e for both
private emails and work emails. Awesome!

#+begin_src emacs-lisp
  (setq mu4e-contexts
     `( ,(make-mu4e-context
           :name "Hotmail"
           :enter-func (lambda () (mu4e-message "Entering hotmail context"))
           :leave-func (lambda () (mu4e-message "Leaving hotmail context"))
           ;; we match based on the contact-fields of the message
           :match-func (lambda (msg)
                         (when msg
                           (mu4e-message-contact-field-matches msg
                             :to "feng_xia41103@hotmail.com")))
           :vars '( ( user-mail-address	    . "feng_xia41103@hotmail.com" )
                    ( user-full-name	    . "Feng Xia" )
                    ( smtpmail-smtp-user . "feng_xia41103@hotmail.com" )
                    ( smtpmail-default-smtp-server . "smtp-mail.outlook.com" )
                    ( smtpmail-smtp-server . "smtp-mail.outlook.com" )
                    ( smtpmail-smtp-service . 587 )
                    ( starttls-use-gnutls . t)
                    ( message-user-organization . "Hotmail" )
                    ( mu4e-compose-reply-to-address . "feng_xia41103@hotmail.com" )
                    ( mu4e-compose-signature .
                      (concat
                        "Best,\n"
                        "feng\n"))))

        ,(make-mu4e-context
           :name "Work"
           :enter-func (lambda () (mu4e-message "Switch to the Work context"))
           ;; no leave-func
           ;; we match based on the maildir of the message
           ;; this matches maildir /Arkham and its sub-directories
           :match-func (lambda (msg)
                         (when msg
                           (string-match-p "^/Mycompany" (mu4e-message-field msg :maildir))))
           :vars '( ( user-mail-address	     . "feng.xia@mycompany.io" )
                    ( user-full-name	     . "Feng Xia" )
                    ( message-user-organization . "Mycompany Inc." )
                    ( smtpmail-smtp-user . "feng.xia@mycompany.io" )
                    ( smtpmail-default-smtp-server . "localhost" )
                    ( smtpmail-smtp-server . "localhost" )
                    ( smtpmail-smtp-service . 1025 )
                    ( starttls-use-gnutls . nil)
                    ( mu4e-compose-reply-to-address . "feng.xia@mycompany.io" )
                    ( mu4e-compose-signature  .
                      (concat
                       "Best regards,\n\n"
                       "Feng Xia\n\n"
                       "W: http://www.mycompany.io\(not )"))))

        ,(make-mu4e-context
           :name "gmail"
           :enter-func (lambda () (mu4e-message "Entering gmail context"))
           :leave-func (lambda () (mu4e-message "Leaving gmail context"))
           ;; we match based on the contact-fields of the message
           :match-func (lambda (msg)
                         (when msg
                           (mu4e-message-contact-field-matches msg
                             :to "fengxia41103@gmail.com")))
           :vars '( ( user-mail-address	    . "fengxia41103@gmail.com" )
                    ( user-full-name	    . "Feng Xia" )
                      ( smtpmail-smtp-user . "fengxia41103@gmail.com" )
                      ( smtpmail-default-smtp-server . "smtp.gmail.com" )
                      ( smtpmail-smtp-server . "smtp.gmail.com" )
                      ( smtpmail-smtp-service . 587 )
                      ( starttls-use-gnutls . t)
                      ( mu4e-compose-reply-to-address . "fengxia41103@gmail.com" )
                      ( message-user-organization . "Gmail" )
                      ( mu4e-compose-signature .
                        (concat
                         "Best,\n"
                         "feng\n"))))
  ))

   ;; set `mu4e-context-policy` and `mu4e-compose-policy` to tweak when mu4e should
   ;; guess or ask the correct context, e.g.

   ;; start with the first (default) context;
   ;; default is to ask-if-none (ask when there's no context yet, and none match)
   ;; (setq mu4e-context-policy 'pick-first)

   ;; compose with the current context is no context matches;
   ;; default is to ask
   ;; (setq mu4e-compose-context-policy nil)
#+end_src

*** how to get mails
Setup location of my maildir.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-maildir (expand-file-name "~/Maildir"))
#+END_SRC


Sync email by calling =mbsync=:
#+BEGIN_SRC emacs-lisp
  (setq mu4e-get-mail-command "mbsync -a")
#+END_SRC


How often should I check? Value in seconds:
#+BEGIN_SRC emacs-lisp
  (setq mu4e-update-interval 300)
#+END_SRC


Setup some common folders:
#+BEGIN_SRC emacs-lisp
  (setq mu4e-drafts-folder "/drafts"
        mu4e-sent-folder   "/sent"
        mu4e-trash-folder  "/trash")
#+END_SRC


Setup some shortcuts as bookmarks:
#+BEGIN_SRC emacs-lisp
  (add-to-list
   'mu4e-bookmarks
   '("flag:attach"
     "Messages with attachment"
     ?a) t)

  (add-to-list
   'mu4e-bookmarks
   '("size:5M..500M"
     "Big messages"
     ?b) t)

  (add-to-list
   'mu4e-bookmarks
   '("flag:flagged"
     "Flagged messages"
     ?f) t)
#+END_SRC

*** list view
Customize the list view header:
#+BEGIN_SRC emacs-lisp
  (setq mu4e-headers-date-format "%b-%d %a"
        mu4e-headers-fields '((:date . 10)
                              (:flags . 5)
                              (:recipnum . 3)
                              (:from-or-to . 10)
                              (:thread-subject . nil)))
#+END_SRC


Skip duplicates:

#+BEGIN_SRC emacs-lisp
  (setq mu4e-headers-skip-duplicates t)
#+END_SRC


Showing related in a tree fashion so I know the context:

#+BEGIN_SRC emacs-lisp
 (setq mu4e-headers-include-related t)
#+END_SRC


Here is a fun one. I noticed that the email thread grows like that greedy snake
game, a pretty good sign that the team is malfunctioning :) So we add a
displayed number on the number of recipients, and just watch it grow:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'mu4e-header-info-custom
               '(:recipnum .
                           ( :name "Number of recipients"  ;; long name, as seen in the message-view
                                   :shortname "R#"           ;; short name, as seen in the headers view
                                   :help "Number of recipients for this message" ;; tooltip
                                   :function (lambda (msg)
                                               (format "%d"
                                                       (+ (length (mu4e-message-field msg :to))
                                                          (length (mu4e-message-field msg :cc))))))))

#+END_SRC

*** read & attachment
Save attachment to:

#+BEGIN_SRC emacs-lisp
  (setq mu4e-attachment-dir "~/Downloads")
#+END_SRC


To open HTML in browser:

#+BEGIN_SRC emacs-lisp
  (setq mu4e-view-use-gnus t)
  (add-to-list 'mu4e-view-actions
  '("ViewInBrowser" . mu4e-action-view-in-browser) t)
  ;(setq mu4e-html2text-command "html2text -b 72 --mark-code")
#+END_SRC


To open a link in email, press ~g~.

Attempt to show images when viewing messages:

#+BEGIN_SRC emacs-lisp
  (setq mu4e-view-show-images t)
#+END_SRC


Use imagemagick, if available:

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))
#+END_SRC

*** write new

My signature line:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq mu4e-compose-signature
        (concat
         "Best regards,\n\n"
         "Feng Xia\n\n"
         "W: http://www.mycompany.io\n"))
#+END_SRC

*** send
Sending email is to use SMTP. Here I'm showing to use the company one
through =davmail= which runs smtp listen on port =1025=. You can also
use Gmail/hotmail:

#+BEGIN_SRC emacs-lisp
  ;;(use-package smtpmail
  ;;  :ensure t
  ;;  :config
  ;;)
  ;; user-mail-address "feng.xia@mycompany.io"
  ;; smtpmail-smtp-user "feng.xia@mycompany.io"
  ;; smtpmail-default-smtp-server "localhost"
  ;; smtpmail-smtp-service 1025
  ;; starttls-use-gnutls nil
    (setq send-mail-function 'smtpmail-send-it
          smtpmail-debug-info t
          smtpmail-auth-credentials (expand-file-name "~/.authinfo")
          smtpmail-stream-type nil
          starttls-extra-arguments nil)
#+END_SRC


There is a toggle where you can queue the sending email first instead
of sending to server immediately. This is useful for travel when you
just write, then queue, then when reconnected to the internect, send.

#+BEGIN_SRC emacs-lisp
  (setq smtpmail-queue-mail nil
        smtpmail-queue-dir "~/Maildir/queue/cur")
#+END_SRC

*** reply
When replying an email, auto fill in my info:

#+BEGIN_SRC emacs-lisp
  ;; mu4e-compose-reply-to-address "feng.xia@mycompany.io"
  ;; user-mail-address "feng.xia@mycompany.io"
  ;; user-full-name "Feng Xia"
  ;; message-signature  (concat
  ;;                     "Feng Xia\n\n"
  ;;                     "W: http://www.mycompany.io\n")
  (setq
          message-citation-line-format "On %Y-%m-%d %H:%M:%S, %f wrote:"
          message-citation-line-function 'message-insert-formatted-citation-line
          mu4e-headers-results-limit 500)
#+END_SRC

*** kill all buffer upon exit
mu4e can open a lot of writing buffers. Just kill them all when we exit mu4e:

#+BEGIN_SRC emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+END_SRC

*** write html
Emacs doesn't like html email body. Nor do I. But one thing I found
out is that markdown mode table will look terrible as plain text on
receiving end. There are a couple ways to work around.

**** write in org

So we now write email in org mode, then call =M-x org-mime-htmlize= to
convert either the whole buffer or a region to html before sending:

#+BEGIN_SRC emacs-lisp
  (use-package org-mime
    :ensure
    :config
    (setq org-mime-export-ascii 'utf-8))
#+END_SRC

**** write in markdown

How about writing it in markdown? You don't need to do much. Switch to
=markdown-mode= to write, then switch back to =mu4e-compose-mode= and
then =C-c C-c= to send:

#+BEGIN_SRC emacs-lisp
  (defun multipart-html-message (plain html)
    "Creates a multipart HTML email with a text part and an html part."
    (concat "<#multipart type=alternative>\n"
            "<#part type=text/plain>"
            plain
            "<#part type=text/html>\n"
            html
            "<#/multipart>\n"))

  (defun convert-message-to-markdown ()
    "Convert the message in the current buffer to a multipart HTML email.

  The HTML is rendered by treating the message content as Markdown."
    (interactive)
    (unless (executable-find "pandoc")
      (error "Pandoc not found, unable to convert message"))
    (let* ((begin
            (save-excursion
              (goto-char (point-min))
              (search-forward mail-header-separator)))
           (end (point-max))
           (html-buf (generate-new-buffer "*mail-md-output*"))
           (exit-code
            (call-process-region begin end "pandoc" nil html-buf nil
                                 "--quiet" "-f" "gfm" "-t" "html"))
           (html (format "<html>\n<head></head>\n<body>\n%s\n</body></html>\n"
                  (with-current-buffer html-buf
                    (buffer-substring (point-min) (point-max)))))
           (raw-body (buffer-substring begin end)))
      (when (not (= exit-code 0))
        (error "Markdown conversion failed, see %s" (buffer-name html-buf)))
      (with-current-buffer html-buf
        (set-buffer-modified-p nil)
        (kill-buffer))
      (undo-boundary)
      (delete-region begin end)
      (save-excursion
        (goto-char begin)
        (newline)
        (insert (multipart-html-message raw-body html)))))

  (defun message-md-send (&optional arg)
    "Convert the current buffer and send it.
  If given prefix arg ARG, skips markdown conversion."
    (interactive "P")
    (unless arg
      (convert-message-to-markdown))
    (message-send))

  (defun message-md-send-and-exit (&optional arg)
    "Convert the current buffer and send it, then exit from mail buffer.
  If given prefix arg ARG, skips markdown conversion."
    (interactive "P")
    (unless arg
      (convert-message-to-markdown))
    (message-send-and-exit))

  (with-eval-after-load 'message
   (define-key message-mode-map (kbd "C-c C-s") #'message-md-send)
   (define-key message-mode-map (kbd "C-c C-c") #'message-md-send-and-exit))
 #+END_SRC

 #+RESULTS:
 : message-md-send-and-exit

*** capture to org

It is possible to capture an email to org as todo shown [[https://www.djcbsoftware.nl/code/mu/mu4e/Org_002dmode-links.html][here]].

#+begin_src emacs-lisp
  (define-key mu4e-headers-mode-map (kbd "C-c c") 'mu4e-org-store-and-capture)
  (define-key mu4e-view-mode-map    (kbd "C-c c") 'mu4e-org-store-and-capture)
#+end_src


** slack

Install slack client. It's a bit involved to get token and cookie, and *you need
both*!

#+BEGIN_SRC emacs-lisp :tangle no
(use-package slack
  :ensure t
  :defer 4
  :init (make-directory "/tmp/emacs-slack-images/" t)
  :bind (:map slack-mode-map
              (("@" . slack-message-embed-mention)
               ("#" . slack-message-embed-channel)))
  :custom
  (slack-buffer-emojify t)
  (slack-prefer-current-team t)
  (slack-image-file-directory "/tmp/emacs-slack-images/")
  (slack-buffer-create-on-notify t)
  (slack-thread-also-send-to-room t)
  :config
    (slack-register-team
     :name "mycompanyio"
     :default t
     :token (auth-source-pick-first-password
             :host "mycompanyio.slack.com"
             :user "feng.xia@mycompany.io^token")
     :cookie (auth-source-pick-first-password
             :host "mycompanyio.slack.com"
             :user "feng.xia@mycompany.io^cookie")
     :subscribed-channels '((eng-chat software_dev))
     :full-and-display-names t)
    (add-to-list 'org-agenda-files "~/workspace/me/org/slack.org"))

;; global start slack
 (slack-start)

;; display a nice timestamp in slack
(setq lui-time-stamp-format "[%Y-%m-%d %H:%M]")
(setq lui-time-stamp-only-when-changed-p t)
(setq lui-time-stamp-position 'right)
(setq lui-time-stamp-face '((t (:foreground "light gray" :weight normal))))
#+END_SRC

Add a hydra:

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "C-c <f3>")
  (defhydra slack-hydra (:hint nil)
    "
      Channel: _c_:channel _l_:update
      Message: _i_:im _u_:update _r_:reaction _e_:edit msg _M-p_:prev _M-n_:next
        Slack: _S_:start _C_: leave
        _q_:cancel
    "


    ("c" slack-channel-select "channel")
    ("l" slack-channel-list-update "channel update")

    ("i" slack-im-select "im")
    ("u" slack-im-list-update "im update")
    ("r" slack-message-add-reaction "reaction")
    ("e" slack-message-edit "edit msg")
    ("M-p" slack-buffer-goto-prev-message)
    ("M-n" slack-buffer-goto-next-message)

    ("S" slack-start "Start")
    ("C" slack-ws-close "Leave")

    ("q"  nil "cancel" :color yellow)))
#+END_SRC

Add alert:

#+BEGIN_SRC emacs-lisp :tangle no
(use-package alert
  :commands (alert)
  :init
  (setq alert-default-style 'libnotify)
)
#+END_SRC


Add slack new msg alert, and add it to an org file.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package alert
  :ensure t
  :init
  (alert-define-style
   'my/alert-style :title
   "Make Org headings for messages I receive - Style"
   :notifier
   (lambda (info)
     (when (get-buffer "slack.org") (with-current-buffer "slack.org" (save-buffer)))
     (write-region
      (s-concat
       "* TODO "
       (plist-get info :title)
       " : "
       (format
        "%s %s :slack:"
        (plist-get info :title)
        (s-truncate 127 (plist-get info :message)))
       "\n"
       (format "\n <%s>" (format-time-string "%Y-%m-%d %H:%M"))
       "\n"
       (plist-get info :message)
       "\n")
      nil
      "~/workspace/me/org/slack.org"
      t)))
  (setq alert-default-style 'message)
  (add-to-list 'alert-user-configuration
               '(((:category . "slack")) my/alert-style nil)))

#+END_SRC

* Hobbies
** elfeed

Read news:
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure
    :config)
  (setq elfeed-feeds
        '(("http://rss.slashdot.org/Slashdot/slashdotMain" dev)
          ("https://fengxia41103.github.io/myblog/feeds/all.atom.xml" me)))
#+END_SRC

** taskjuggler
#+BEGIN_SRC emacs-lisp
  (use-package tj3-mode
    :ensure t
    :after org-plus-contrib
    :config
    (require 'ox-taskjuggler)
    (custom-set-variables
     '(org-taskjuggler-process-command "/usr/local/bin/tj3 --silent --no-color --output-dir %o %f")
     '(org-taskjuggler-project-tag "PRJ")))
#+END_SRC

* My doc writing

Writing doc is painful, not because I don't like writing, but because
I hate WORD. So I have been trying all kinds of things to generate PDF
and have people accept my PDF. I used to write simply in LaTex,
plain. Then of course there is the big-org which can be converted. But
since I have been writing a lot of Markdown for my blogs, I don't feel
like converting all my writings into `.org` just fo the sake of org
mode. So instead, I have had success in writing the Pandoc version of
Markdown for my two Lenovo reference architecture papers, and I think
it gives me more control of the LaTex template, the CSS file I can
customize, and so on. So I'll stick to it for now.

** pandoc

#+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
    :ensure)
  (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)
#+END_SRC

* The big Org

Org-mode is, overwhelming! It can do a lot, and it takes a long time
for me to understand what it does (and what it doesn't). Part of this
config in org mode is just the way to force myself to learn org mdoe
and write things in org mode. I haven't yet taken full advantage of
its TODO capability. Well, one day.

** init

If variable =org-directory= is not set yet, map it to my home's
files. You may set this in the =~/.emacs= to another value,
e.g. =(setq org-directory "/ssh:fleury@machine.site.com:OrgFiles")=

*** NEXT This does not seem to work, check out doc about [[https://stackoverflow.com/questions/3806423/how-can-i-get-a-variables-initial-value-in-elisp][defcustom]]
:LOGBOOK:
- State "NEXT"       from              [2019-06-24 Mon 10:10]
:END:

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure nil
    :delight org-mode
    :config
    :hook ((org-mode . visual-line-mode)
           (org-mode . variable-pitch-mode)
           (org-mode . org-indent-mode)))

#+END_SRC

** others

Don't know what they belong to. Just stuck them here. There are some functions
used by the following code. So unfortunately this section must comes in early.

*** by packages
**** org-protocol

Let other tools use emacs client to interact

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

**** org-board
Archive entire sites locally with `wget`.

#+BEGIN_SRC emacs-lisp
  (use-package org-board
    :ensure t
    :config
    (global-set-key (kbd "C-c o") org-board-keymap))
#+END_SRC

**** image (M-I)

Make the display of images a simple key-stroke away.

#+BEGIN_SRC emacs-lisp
  (defun paf/org-toggle-iimage-in-org ()
    "display images in your org file"
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline 'org-link nil)
      (set-face-underline 'org-link t))
    (iimage-mode 'toggle))

  (use-package iimage
    :config
    (add-to-list 'iimage-mode-image-regex-alist
                 (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                               "\\)\\]")  1))
    (add-hook 'org-mode-hook (lambda ()
                               ;; display images
                               (local-set-key "\M-I" 'paf/org-toggle-iimage-in-org)
                              )))
#+END_SRC

*** snippets found online

Some helper snippets found online.

**** Open remote org dir

In your =.emacs= just add this to configure the location:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq remote-org-directory "/ssh:fleury@my.hostname.com:OrgFiles")
#+END_SRC

Then you can use the keyboard shortcut to open that dir.

#+BEGIN_SRC emacs-lisp
  (defcustom remote-org-directory "~/OrgFiles"
    "Location of remove OrgFile directory, should you have one."
    :type 'string
    :group 'paf)
  (defun paf/open-remote-org-directory ()
    (interactive)
    (find-file remote-org-directory))

  (global-set-key (kbd "C-M-x r o") 'paf/open-remote-org-directory)
#+END_SRC

**** Org-relative file function

#+BEGIN_SRC emacs-lisp
(defun org-relative-file (filename)
  "Compute an expanded absolute file path for org files"
  (expand-file-name filename org-directory))
#+END_SRC

**** Adjust tags on the right

Dynamically adjust tag position [[https://orgmode.org/worg/org-hacks.html#org0560357][source on worg]]

#+BEGIN_SRC emacs-lisp :tangle no
(defun ba/org-adjust-tags-column-reset-tags ()
  "In org-mode buffers it will reset tag position according to
`org-tags-column'."
  (when (and
         (not (string= (buffer-name) "*Remember*"))
         (eql major-mode 'org-mode))
    (let ((b-m-p (buffer-modified-p)))
      (condition-case nil
          (save-excursion
            (goto-char (point-min))
            (command-execute 'outline-next-visible-heading)
            ;; disable (message) that org-set-tags generates
            (cl-letf (((symbol-function 'message) #'format))
              (org-set-tags 1 t))
            (set-buffer-modified-p b-m-p))
        (error nil)))))

(defun ba/org-adjust-tags-column-now ()
  "Right-adjust `org-tags-column' value, then reset tag position."
  (set (make-local-variable 'org-tags-column)
       (- (- (window-width) (length org-ellipsis))))
  (ba/org-adjust-tags-column-reset-tags))

(defun ba/org-adjust-tags-column-maybe ()
  "If `ba/org-adjust-tags-column' is set to non-nil, adjust tags."
  (when ba/org-adjust-tags-column
    (ba/org-adjust-tags-column-now)))

(defun ba/org-adjust-tags-column-before-save ()
  "Tags need to be left-adjusted when saving."
  (when ba/org-adjust-tags-column
     (setq org-tags-column 1)
     (ba/org-adjust-tags-column-reset-tags)))

(defun ba/org-adjust-tags-column-after-save ()
  "Revert left-adjusted tag position done by before-save hook."
  (ba/org-adjust-tags-column-maybe)
  (set-buffer-modified-p nil))

;; between invoking org-refile and displaying the prompt (which
;; triggers window-configuration-change-hook) tags might adjust,
;; which invalidates the org-refile cache
(defadvice org-refile (around org-refile-disable-adjust-tags)
  "Disable dynamically adjusting tags"
  (let ((ba/org-adjust-tags-column nil))
    ad-do-it))
(ad-activate 'org-refile)

;; Now set it up
(setq ba/org-adjust-tags-column t)
;; automatically align tags on right-hand side
;; TODO(fleury): Does not seem to work as of 2017/12/18
;; Seems to work again 2018/11/01
(add-hook 'window-configuration-change-hook
          'ba/org-adjust-tags-column-maybe)
(add-hook 'before-save-hook 'ba/org-adjust-tags-column-before-save)
(add-hook 'after-save-hook 'ba/org-adjust-tags-column-after-save)
(add-hook 'org-agenda-mode-hook (lambda ()
                                  (setq org-agenda-tags-column (- (window-width)))))
#+END_SRC

***** TODO Update =org-set-tags-to=
:LOGBOOK:
- State "TODO"       from              [2019-01-12 Sat 12:08]
:END:
[[https://orgmode.org/worg/doc.html#org-set-tags-to][=org-set-tags-to=]] is gone, and =org-set-tags= with > 1 args is not working.
Not sure what to replace it with though...

**** Preserve structure in archives

Make sure archiving preserves the same tree structure, including when
archiving subtrees.  [[https://orgmode.org/worg/org-hacks.html#org4265b4c][source on org]]

#+BEGIN_SRC emacs-lisp
(defun my-org-inherited-no-file-tags ()
  (let ((tags (org-entry-get nil "ALLTAGS" 'selective))
        (ltags (org-entry-get nil "TAGS")))
    (mapc (lambda (tag)
            (setq tags
                  (replace-regexp-in-string (concat tag ":") "" tags)))
          (append org-file-tags (when ltags (split-string ltags ":" t))))
    (if (string= ":" tags) nil tags)))
#+END_SRC

This used to work, but =org-extract-archive-file= is no longer defined.

#+BEGIN_SRC emacs-lisp :tangle no
(defadvice org-archive-subtree
    (around my-org-archive-subtree-low-level activate)
  (let ((tags (my-org-inherited-no-file-tags))
        (org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it
    (with-current-buffer (find-file-noselect (org-extract-archive-file))
      (save-excursion
        (while (org-up-heading-safe))
        (org-set-tags tags)))))
#+END_SRC
**** Properties collector (default: off)

Collect properties into tables. See documentation in the file.

#+BEGIN_SRC emacs-lisp :tangle no
  (load-file "~/Emacs/org-collector.el")
#+END_SRC

**** access org file remotely via SSH

Let's bind this to a key, so I can open remote dirs. I suually put
this in my =.emacs= as it is host- and user-specific.

#+BEGIN_SRC emacs-lisp :tangle no
(defun paf/open-remote-org-dir ()
  (interactive)
  (dired "/ssh:remote.host.com:org"))

(global-set-key (kbd "C-M-x r o") 'paf/open-remote-org-dir)
#+END_SRC

**** bash command
#+BEGIN_SRC emacs-lisp
  (setq org-babel-sh-command "bash")
#+END_SRC

**** OrgRoam templates

#+BEGIN_SRC emacs-lisp
  (setq org-roam-capture-templates
        `(("m" "Meeting" entry (function org-roam--capture-get-point)
               "* %?\n%U\n%^{with}\n"
               :file-name "meeting/%<%Y%m%d%H%M%S>-${slug}"
               :head "#+title: ${title}\n#+roam_tags: %^{with}\n\n"
               )))

#+END_SRC

** key mappings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)

  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "C-<up>") 'org-move-subtree-up)
              (local-set-key (kbd "C-<down>") 'org-move-subtree-down)
              (local-set-key (kbd "C-c C-l") 'org-insert-link)))

#+END_SRC

** display settings
Some config for display. Some of these are borrowed from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][here]]:

#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars t)

  ;; auto log a clock when task is closed
  (setq org-log-done t)

  (setq org-startup-indented t)
  (setq org-startup-folded t)
  (setq org-ellipsis "...")
  (setq org-hide-emphasis-markers t)
#+END_SRC

*** org-bullets

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-bullets
    :ensure
    :hook (org-mode . org-bullets-mode))
#+END_SRC

*** headline font

This will make headline and text body different font size.
#+BEGIN_SRC emacs-lisp

(let* ((variable-tuple
          (cond ((x-list-fonts "ETBembo")         '(:font "ETBembo"))
                ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana")         '(:font "Verdana"))
                ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (headline           `(:inherit default :weight bold :foreground "#F5F5F5")))

    (custom-theme-set-faces
     'user
     `(org-level-8 ((t (,@headline ,@variable-tuple))))
     `(org-level-7 ((t (,@headline ,@variable-tuple))))
     `(org-level-6 ((t (,@headline ,@variable-tuple))))
     `(org-level-5 ((t (,@headline ,@variable-tuple))))
     `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.0))))
     `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.1 :foreground "#FEB236"))))
     `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.2 :foreground "burleywood"))))
     `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.3))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))
#+END_SRC

*** custom font
Tweaks to customize font faces in org found [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][here]]:

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(default ((t (:background nil))))
 '(aw-leading-char-face ((t (:inherit ace-jump-face-foreground :foreground "#D52349" :height 1000 :overline t :box nil))))
 '(fixed-pitch ((t (:family "Fira Code" :height 140))))
 '(font-lock-comment-face ((t (:foreground "dim gray" :slant oblique))))
 '(highlight ((t (:background "forest green"))))
 '(magit-branch-current ((t (:foreground "red" :box 1 :weight bold :height 2.0))))
 '(magit-branch-local ((t (:foreground "tomato" :weight bold))))
 '(magit-branch-remote ((t (:foreground "yellow"))))
 '(magit-diff-context-highlight ((t (:background "#ffffff" :foreground "dim gray"))))
 '(magit-diff-file-heading-highlight ((t (:background "#ffffff" :foreground "black" :weight bold))))
 '(magit-diff-hunk-heading ((t (:background "gainsboro" :foreground "tomato"))))
 '(magit-diff-hunk-heading-highlight ((t (:background "DarkGoldenrod3" :foreground "black"))))
 '(magit-diff-revision-summary ((t (:inherit magit-diff-hunk-heading :foreground "black"))))
 '(magit-diff-revision-summary-highlight ((t (:foreground "gold"))))
 '(magit-section-heading-selection ((t (:foreground "dark red" :weight bold))))
 '(magit-section-highlight ((t (:background "tan4"))))
 '(markdown-code-face ((t (:background "gray10"))))
 '(org-agenda-current-time ((t (:inherit org-time-grid :foreground "yellow" :weight bold))))
 '(org-agenda-date ((t (:inherit org-agenda-structure :background "pale green" :foreground "black" :weight bold))))
 '(org-agenda-date-weekend ((t (:inherit org-agenda-date :background "light blue" :weight bold))))
 '(org-block ((t (:inherit fixed-pitch :foreground "light gray"))))
 '(org-block-background ((t (:background "gray10"))))
 '(org-block-begin-line ((t (:underline "#A7A6AA" :foreground "GreenYellow" :background "gray30" :extend t))))
 '(org-block-end-line ((t (:underline "#A7A6AA" :foreground "GreenYellow" :background "gray30" :extend t))))
 '(org-bold ((t (:foreground "#d52349"))))
 '(org-code ((t (:inherit (shadow fixed-pitch) :foreground "tomato"))))
 '(org-document-info ((t (:foreground "dark orange"))))
 '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
 '(org-document-title ((t (:inherit default :weight bold :foreground "#F5F5F5" :family "Sans Serif" :height 1.5 :underline nil))))
 '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
 '(org-level-1 ((t (:inherit default :weight bold :foreground "#F5F5F5" :height 1.3))))
 '(org-level-2 ((t (:inherit default :weight bold :foreground "seashell" :height 1.2))))
 '(org-level-3 ((t (:inherit default :weight bold :height 1.1 :foreground "#FEB236"))))
 '(org-level-4 ((t (:inherit default :weight bold :foreground "#F5F5F5"))))
 '(org-level-5 ((t (:inherit default :weight bold :foreground "#F5F5F5"))))
 '(org-level-6 ((t (:inherit default :weight bold :foreground "#F5F5F5"))))
 '(org-level-7 ((t (:inherit default :weight bold :foreground "#F5F5F5"))))
 '(org-level-8 ((t (:inherit default :weight bold :foreground "#F5F5F5"))))
 '(org-link ((t (:inherit fixed-pitch :foreground "royal blue" :underline t))))
 '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-property-value ((t (:inherit fixed-pitch))) t)
 '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
 '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold))))
 '(org-verbatim ((t (:inherit (shadow fixed-pitch) :foreground "tomato"))))
 '(org-column ((t (:inherit fixed-pitch))))
 '(region ((t (:background "forest green")))))
#+END_SRC

** writing stuff

Part 1, writing stuff such as taking notes.

*** by packages
**** Zetteldeft

This is a note-taking packages inspired by the principles of the
[[https://zettelkasten.de/][Zettelkasteno.]]

#+BEGIN_SRC emacs-lisp
  (use-package deft
    :ensure t)
  (use-package avy
    :ensure t)

  (use-package zetteldeft
    :ensure t
    :after (org deft avy)

    :config
    (setq deft-extensions '("org" "md" "txt"))
    (setq deft-directory (org-relative-file "Zettelkasten"))
    (setq deft-recursive t)

    :bind (("C-c z d" . deft)
           ("C-c z D" . zetteldeft-deft-new-search)
           ("C-c z R" . deft-refresh)
           ("C-c z s" . zetteldeft-search-at-point)
           ("C-c z c" . zetteldeft-search-current-id)
           ("C-c z f" . zetteldeft-follow-link)
           ("C-c z F" . zetteldeft-avy-file-search-ace-window)
           ("C-c z l" . zetteldeft-avy-link-search)
           ("C-c z t" . zetteldeft-avy-tag-search)
           ("C-c z T" . zetteldeft-tag-buffer)
           ("C-c z i" . zetteldeft-find-file-id-insert)
           ("C-c z I" . zetteldeft-find-file-full-title-insert)
           ("C-c z o" . zetteldeft-find-file)
           ("C-c z n" . zetteldeft-new-file)
           ("C-c z N" . zetteldeft-new-file-and-link)
           ("C-c z r" . zetteldeft-file-rename))
  )
#+END_SRC

**** plant-uml

Tell where PlantUML is to be found. This needs to be downloaded and
installed separately, see the [[http://plantuml.com/][PlantUML website]].

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
 :ensure t
 :config
  (setq plantuml-jar-path "~/workspace/me/myblog/content/downloads/plantuml.jar")
  (setq org-plantuml-jar-path "~/workspace/me/myblog/content/downloads/plantuml.jar")
  ;; Let us edit PlantUML snippets in plantuml-mode within orgmode
  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  ;; make it load this language (for export ?)
  (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
  ;; Enable plantuml-mode for PlantUML files
  (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode)))
#+END_SRC

*** org-link-abbrev

This lets one write links as e.g. [ [b:123457] ]

#+BEGIN_SRC emacs-lisp
(setq org-link-abbrev-alist
      '(("b" . "http://b/")
        ("go" . "http://go/")
        ("cl" . "http://cr/")))
#+END_SRC

*** auto line wrap

Wrap around after 80 columns. The key is auto-fill mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook '(lambda () (setq fill-column 80)))
(add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

** export

Part 2, exporting.

This is big deal. It took me a while to learn org, and even right now
I still don't know how to use it for schedule management. This feels
like latex, it's wonderful, but not common among non-org-mode folks.

Add a few formats to the export functionality of org-mode.

*** org-babel

What kind of code block languages do I need

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate 'nil) ; Don't ask before executing

  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (R . t)
     (dot . t)
     (emacs-lisp . t)
     (gnuplot . t)
     (python . t)
     ;;(sh . t)
     (latex . t)
     (shell . t)
    ))
#+END_SRC

*** markdown

#+BEGIN_SRC emacs-lisp
  (use-package ox-md
    :defer)
#+END_SRC

*** beamer

#+BEGIN_SRC emacs-lisp
  (use-package ox-beamer
    :defer)
#+END_SRC

*** org-reveal

You need to install =reveal.js= offline, then specify its path here.
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t
    :after (htmlize)
    :config
    (setq org-reveal-root (expand-file-name "~/reveal.js")))

  (use-package htmlize
    :ensure t)
#+END_SRC

*** odt

#+BEGIN_SRC emacs-lisp
  (use-package ox-odt
    :defer)
#+END_SRC

*** taskjuggler

#+BEGIN_SRC emacs-lisp
  (use-package ox-taskjuggler
    :defer)
#+END_SRC

*** confluence
#+BEGIN_SRC emacs-lisp
  (use-package ox-confluence
    :defer)
#+END_SRC

** managing life (aka. agenda/todo)

Part 3 of org, managing TODOs.


*** where are my agenda files

#+begin_src emacs-lisp
  (setq org-agenda-files   (list "~/workspace/me/org/")
        org-log-done 'time
        )
#+end_src

*** by packages
**** org-super-agenda

This enables a more fine-grained filtering of the agenda items.

#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :config
    (org-super-agenda-mode t))
#+END_SRC

**** org-clock-convenience

#+BEGIN_SRC emacs-lisp
  (use-package org-clock-convenience
    :ensure t
    :bind (:map org-agenda-mode-map
             ("<S-right>" . org-clock-convenience-timestamp-up)
             ("<S-left>" . org-clock-convenience-timestamp-down)
             ("[" . org-clock-convenience-fill-gap)
             ("]" . org-clock-convenience-fill-gap-both)))
#+END_SRC

**** org-habit

#+BEGIN_SRC emacs-lisp
(use-package org-habit
  :delight
  :config
  (setq org-habit-graph-column 38)
  (setq org-habit-preceding-days 35)
  (setq org-habit-following-days 10)
  (setq org-habit-show-habits-only-for-today nil))
#+END_SRC

**** org-secretary

This package is good, but it does not do it simply. I re-modeled it
somewhat below.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-secretary
    :ensure org-plus-contrib
    :config
    (setq org-sec-me "feng")
    (setq org-tag-alist '(("PRJ" . ?p)
                          ("DESIGNDOC" . ?D)
                          ("Milestone" . ?m)
                          ("DESK" . ?d)
                          ("HOME" . ?h)
                          ("VC" . ?v))))
#+END_SRC

This is my version of the org-secretary
#+BEGIN_SRC emacs-lisp
    (use-package paf-secretary
      :load-path "~/Emacs"
      :bind (("\C-cw" . paf-sec-set-with)
             ("\C-cW" . paf-sec-set-where)
             ("\C-cj" . paf-sec-tag-entry))
      :config
      (setq paf-sec-me "paf")
      (setq org-tag-alist '(("PRJ" . ?p)
                            ("DESIGNDOC" . ?D)
                            ("Milestone" . ?m)
                            ("DESK" . ?d)
                            ("HOME" . ?h)
                            ("VC" . ?v))))
#+END_SRC
**** org-duration

#+BEGIN_SRC emacs-lisp
  (use-package org-duration
    :config
    (setq org-duration-units
          `(("min" . 1)
            ("h" . 60)
            ("d" . ,(* 60 8))
            ("w" . ,(* 60 8 5))
            ("m" . ,(* 60 8 5 4))
            ("y" . ,(* 60 8 5 4 10)))
          )
    (org-duration-set-regexps))
#+END_SRC

*** keywords & status state machine

TODO doesn't have to have a special keyword. However, once you have a
list, you can enjoy things like color coded font, status transition
timestamp, and kinda of query report such as "give me the list of my
<meetings>". Just convenient.

The state machine is essentially your workflow, how you want to take a
task through its stages, eg. from ready to in-progress to in-review to
done. So really, develop a workflow of your own that fits your way of
thinking, and it should feel natural how you handle a todo in daily
life.

I think this is the single most challenging point to adopt Org because
people, myself included, are hardly capable to analyze your own task
handling habit to abstract such workflow. Company hires consulting
firms to do that for them; an individual, unlikely. We coast along
life everyday, but who can write down "here is how I get a TODO off my
list, each time!?".

Anyway, I think adopting Org is essentially to force yourself into a
*routine* that is codified. It sounds rigid, IT-ish. But for efficiency,
it's a necessary evil.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "WORKING(w!)" "|" "DONE(d!)" "CANCELLED(C@)" "DEFERRED(D@)" "SOMEDAY(S!)" "FAILED(F!)" "REFILED(R!)")
          (sequence "TASK(m!)" "ACTIVE" "|" "DONE(d!)" "CANCELLED(C@)" )))

  (setq org-tags-exclude-from-inheritance '("PRJ" "REGULAR")
        org-use-property-inheritance '("PRIORITY")
        org-stuck-projects '("+PRJ/-DONE-CANCELLED"
                             ;; it is considered stuck if there is no next action
                             (;"TODO"
                              "WORKING" "ACTIVE" "TASK") ()))

  (setq org-todo-keyword-faces
        '(
          ("TODO" . (:foreground "GhostWhite" :weight bold))
          ("TASK" . (:foreground "steelblue" :weight bold))
          ("NEXT" . (:foreground "red" :weight bold))
          ("STARTED" . (:foreground "green" :weight bold))
          ("WAITING" . (:foreground "orange" :weight bold))
          ("FLAG_GATED" . (:foreground "orange" :weight bold))
          ("SOMEDAY" . (:foreground "steelblue" :weight bold))
          ("MAYBE" . (:foreground "steelblue" :weight bold))
          ("AI" . (:foreground "red" :weight bold))
          ("NEW" . (:foreground "orange" :weight bold))
          ("RUNNING" . (:foreground "orange" :weight bold))
          ("WORKED" . (:foreground "green" :weight bold))
          ("FAILED" . (:foreground "red" :weight bold))
          ("REFILED" . (:foreground "gray"))
          ;; For publications
          ("APPLIED" . (:foreground "orange" :weight bold))
          ("ACCEPTED" . (:foreground "orange" :weight bold))
          ("REJECTED" . (:foreground "red" :weight bold))
          ("PUBLISHED" . (:foreground "green" :weight bold))
          ;; Other stuff
          ("ACTIVE" . (:foreground "darkgreen" :weight bold))
          ))
#+END_SRC

*** priorities

Set color for priorities based on [[http://pragmaticemacs.com/emacs/org-mode-basics-vi-a-simple-todo-list/][this]].
#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '((?A . (:foreground "OrangeRed" :weight bold))
                           (?B . (:foreground "LightSteelBlue"))
                           (?C . (:foreground "OliveDrab"))))
#+END_SRC

*** capture & refile

Capture and refile stuff, with some templates that I think are useful.

Very nice post on how to get capture templats from a file: [[https://joshrollinswrites.com/help-desk-head-desk/org-capture-in-files/][Org-capture
in Files]].

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (org-relative-file "~/workspace/me/org/tasks.org"))

  (setq org-capture-templates
        `(("t" "Task"
           entry (file+headline ,(org-relative-file "~/workspace/me/org/tasks.org") "Tasks")
           "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n"
           :clock-resume t)
          ;;
          ("i" "Idea"
           entry (file+headline ,(org-relative-file "~/workspace/me/org/tasks.org") "Ideas")
           "* SOMEDAY %?\n%U\n\n%x"
           :clock-resume t)
          ;;
          ("m" "Meeting"
           entry (file+headline ,(org-relative-file "~/workspace/me/org/meeting.org") "Meetings")
           "* %?  :MTG:\n%U\n%^{with}p")

          ;;
          ("s" "Stand-up"
           entry (file+headline ,(org-relative-file "~/workspace/me/org/tasks.org") "Meetings")
           "* Stand-up  :MTG:\n%U\n\n%?")

          ;;
          ("1" "1:1"
           entry (file+headline ,(org-relative-file "~/workspace/me/org/meeting.org") "Meetings")
           "* 1:1 %^{With}  :MTG:\n%U\n:PROPERTIES:\n:with: %\\1\n:END:\n\n%?")

          ;;
          ("e" "Emails" entry (file+headline "~/workspace/me/org/tasks.org" "Emails")
           "* TODO %:fromname: %a %?\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))")
          ;;
          ("j" "Jobs" entry (file+headline "~/workspace/me/org/jobs.org" "Interviews")
           "* TODO %:fromname: %a %?\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+1d\"))")
          ;;
          ("j" "Journal"
           entry (file+olp+datetree ,(org-relative-file "~/workspace/me/org/journal.org"))
           "* %?\n%U"
           :clock-in t
           :clock-resume t
           :kill-buffer t)))

  ;; show up to 2 levels for refile targets, in all agenda files
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 2))))
  (setq org-log-refile t)  ;; will add timestamp when refiled.

  ;; from: http://doc.norang.ca/org-mode.html
  ;; Exclude DONE state tasks from refile targets
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))
  (setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_SRC

*** task tracking

Track task dependencies, and dim them in the agenda.

#+BEGIN_SRC emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC

*** effort & columns mode

#+BEGIN_SRC emacs-lisp
  (setq org-global-properties
        '(("Effort_ALL". "0 0:10 0:30 1:00 2:00 4:00 8:00 16:00")))
  (setq org-columns-default-format
        "%TODO %30ITEM %3PRIORITY %6Effort{:} %10DEADLINE")
#+END_SRC

*** shortcut to open first agenda file

F12 open the first agenda file

#+BEGIN_SRC emacs-lisp
  (defun org-get-first-agenda-file ()
    (interactive)
    (find-file (elt org-agenda-files 0)))
  (global-set-key [f12] 'org-get-first-agenda-file)
  ; F12 on Mac OSX displays the dashboard....
  (global-set-key [C-f12] 'org-get-first-agenda-file)
#+END_SRC

*** org-agenda
**** views
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("t" "Hot Today" ((agenda "" ((org-agenda-span 'day)))
                            (tags-todo "-with={.+}/WAITING")
                            (tags-todo "-with={.+}+TODO=\"STARTED\"")
                            (tags-todo "/NEXT")))
          ("T" "Team Today" ((agenda "" ((org-agenda-span 'day)))
                             (tags-todo "with={.+}"
                                      ((org-super-agenda-groups
                                        '((:auto-property "with"))))
                                      )))
          ("r" "Recurring" ((tags "REGULAR")
                            (tags-todo "/WAITING")
                            (tags-todo "TODO=\"STARTED\"")
                            (tags-todo "/NEXT")))
          ("n" "Agenda and all TODO's" ((agenda "")
                                        (alltodo "")))
          ("N" "Next actions" tags-todo "-dowith={.+}/!-TASK-TODO"
           ((org-agenda-todo-ignore-scheduled t)))
          ("h" "Work todos" tags-todo "-dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled t)))
          ("H" "All work todos" tags-todo "-personal/!-TASK-CANCELLED"
           ((org-agenda-todo-ignore-scheduled nil)))
          ("A" "Work todos with doat or dowith" tags-todo
           "dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled nil)))

          ("p" "Tasks with current WITH and WHERE"
           ((tags-todo (paf-sec-replace-with-where "with={$WITH}" ".+")
                       ((org-agenda-overriding-header
                         (paf-sec-replace-with-where "Tasks with $WITH in $WHERE" "anyone" "any place"))
                        (org-super-agenda-groups
                         '((:name "" :pred paf-sec-limit-to-with-where)
                           (:discard (:anything t)))))
                       )))
          ("j" "TODO dowith and TASK with"
           ((org-sec-with-view "TODO dowith")
            (org-sec-stuck-with-view "TALK with")
            (org-sec-where-view "TODO doat")
            (org-sec-assigned-with-view "TASK with")
            (org-sec-stuck-with-view "STUCK with")
            (todo "STARTED")))
          ("J" "Interactive TODO dowith and TASK with"
           ((org-sec-who-view "TODO dowith")))))

  (setq org-agenda-skip-deadline-prewarning-if-scheduled 2)
#+END_SRC

**** delight
#+BEGIN_SRC emacs-lisp
  (delight 'org-agenda-mode)
#+END_SRC

**** colors and faces

Make the calendar day info a bit more visible and contrasted.

#+BEGIN_SRC emacs-lisp
  ;; Faces to make the calendar more colorful.
  (custom-set-faces
   '(org-agenda-current-time ((t (:inherit org-time-grid :foreground "yellow" :weight bold))))
   '(org-agenda-date ((t (:inherit org-agenda-structure :background "pale green" :foreground "black" :weight bold))))
   '(org-agenda-date-weekend ((t (:inherit org-agenda-date :background "light blue" :weight bold)))))
#+END_SRC

**** now marker

A more visible current-time marker in the agenda

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-current-time-string ">>>>>>>>>> NOW <<<<<<<<<<")
#+END_SRC

**** auto-refresh

#+BEGIN_SRC emacs-lisp
  ;; will refresh it only if already visible
  (run-at-time nil 180 'update-agenda-if-visible)
  ;;(add-hook 'org-mode-hook
  ;;          (lambda () (run-at-time nil 180 'kiwon/org-agenda-redo-in-other-window)))
#+END_SRC


This would open the agenda if any org file was opened. In the end, I
don't like this feature, so it is disabled by not tangling it.

#+BEGIN_SRC emacs-lisp :tangle no
  ;; Make this happen only if we open an org file.
  (add-hook 'org-mode-hook
            (lambda () (run-with-idle-timer 600 t 'jump-to-org-agenda)))
#+END_SRC

**** auto-save org files when idle

This will save them regularly when the idle for more than a minute.

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'org-mode-hook
            (lambda () (run-with-idle-timer 600 t 'org-save-all-org-buffers)))
#+END_SRC

**** export

That's the export function to update the agenda view.

#+BEGIN_SRC emacs-lisp :tangle no
(setq org-agenda-exporter-settings
      '((ps-number-of-columns 2)
        (ps-portrait-mode t)
        (org-agenda-add-entry-text-maxlines 5)
        (htmlize-output-type 'font)))

(defun dmg-org-update-agenda-file (&optional force)
  (interactive)
  (save-excursion
    (save-window-excursion
      (let ((file "~/www/agenda/agenda.html"))
        (org-agenda-list)
        (org-agenda-write file)))))
#+END_SRC

**** Auto-Refresh Agenda

Refresh org-mode agenda regularly.  [[https://orgmode.org/worg/org-hacks.html#orgab827a7][source on worg]] There are two
functions that supposedly do the same.

#+BEGIN_SRC emacs-lisp
(defun kiwon/org-agenda-redo-in-other-window ()
  "Call org-agenda-redo function even in the non-agenda buffer."
  (interactive)
  (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
    (when agenda-window
      (with-selected-window agenda-window (org-agenda-redo)))))

(defun update-agenda-if-visible ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (org-agenda-redo))))
#+END_SRC

**** Display Agenda when idle

Show the agenda when emacs left idle.  [[https://orgmode.org/worg/org-hacks.html#orgaea636d][source on worg]]

#+BEGIN_SRC emacs-lisp
(defun jump-to-org-agenda ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (if (setq wind (get-buffer-window buf))
            (select-window wind)
          (if (called-interactively-p 'any)
              (progn
                (select-window (display-buffer buf t t))
                (org-fit-window-to-buffer)
                (org-agenda-redo)
                )
            (with-selected-window (display-buffer buf)
              (org-fit-window-to-buffer)
              ;;(org-agenda-redo)
              )))
      (call-interactively 'org-agenda-list)))
  ;;(let ((buf (get-buffer "*Calendar*")))
  ;;  (unless (get-buffer-window buf)
  ;;    (org-agenda-goto-calendar)))
  )
#+END_SRC

**** Display location in agenda

From some help on [[https://emacs.stackexchange.com/questions/26249/customize-text-after-task-in-custom-org-agenda-view][this page]] I think this could work:

#+BEGIN_SRC emacs-lisp
  (defun paf/org-agenda-get-location()
    "Gets the value of the LOCATION property"
    (let ((loc (org-entry-get (point) "LOCATION")))
      (if (> (length loc) 0)
          loc
        "")))
#+END_SRC


Also, to set this after org-mode has loaded ([[https://emacs.stackexchange.com/questions/19091/how-to-set-org-agenda-prefix-format-before-org-agenda-starts][see here]]):
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'org-agenda
    (add-to-list 'org-agenda-prefix-format
                 '(agenda . "  %-12:c%?-12t %(paf/org-agenda-get-location)% s"))
#+END_SRC

*** org-clock properties

Good [[https://writequit.org/denver-emacs/presentations/2017-04-11-time-clocking-with-org.html][note about using the clock.]]

Clock stuff into a drawer.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-into-drawer t)
  (setq org-log-into-drawer t)
  (setq org-clock-int-drawer "CLOCK")
#+END_SRC

And according to [[https://orgmode.org/manual/Clocking-Work-Time.html][this]], set clock history:

#+begin_src emacs-lisp
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
#+end_src

Set clock out upon task done and prettify:

#+begin_src emacs-lisp
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; use pretty things for the clocktable
(setq org-pretty-entities t)
#+end_src

** LAST step: reload org

Ran into a [[https://github.com/seagle0128/.emacs.d/issues/129][strange error]], and reloading org at the end is the
solution:

#+BEGIN_SRC emacs-lisp
  (org-mode-restart)
#+END_SRC

* THE END
